Directory structure:
└── henriquecarlosdiniz-teste_chatbot/
    ├── README.md
    ├── artisan
    ├── composer.json
    ├── docker-compose.yml
    ├── Dockerfile
    ├── estrutura_chat_sessions.txt
    ├── package.json
    ├── phpunit.xml
    ├── vite.config.js
    ├── .editorconfig
    ├── .env.example
    ├── app/
    │   ├── Adapters/
    │   │   ├── Ai/
    │   │   │   ├── AiAdapterInterface.php
    │   │   │   ├── ChatGPTAdapter.php
    │   │   │   └── PrismAdapter.php
    │   │   └── Messaging/
    │   │       ├── MessagingAdapterInterface.php
    │   │       ├── WebAdapter.php
    │   │       └── WhatsAppAdapter.php
    │   ├── Chat/
    │   │   ├── ChatApplicationManager.php
    │   │   ├── ConversationAnalyzerService.php
    │   │   ├── FunctionResponseFormatterService.php
    │   │   ├── GeneralIntentClassifier.php
    │   │   ├── IntentManager.php
    │   │   ├── PromptManager.php
    │   │   ├── ResponseAnalyzer.php
    │   │   ├── SentimentAnalyzerService.php
    │   │   ├── Applications/
    │   │   │   ├── BookingApplication.php
    │   │   │   ├── ExistingAppointmentApplication.php
    │   │   │   └── GreetingApplication.php
    │   │   ├── Contracts/
    │   │   │   └── ChatApplicationInterface.php
    │   │   ├── Enums/
    │   │   │   └── BookingState.php
    │   │   ├── Flows/
    │   │   │   ├── BookingFlowManager.php
    │   │   │   └── BookingFlow/
    │   │   │       ├── StateHandlerFactory.php
    │   │   │       ├── Contracts/
    │   │   │       │   └── StateHandler.php
    │   │   │       └── States/
    │   │   │           ├── AbstractStateHandler.php
    │   │   │           ├── AwaitingConfirmationState.php
    │   │   │           ├── AwaitingCorrectionState.php
    │   │   │           ├── AwaitingDateTimeState.php
    │   │   │           ├── AwaitingLocationChoiceState.php
    │   │   │           ├── AwaitingLocationState.php
    │   │   │           ├── AwaitingNameState.php
    │   │   │           ├── AwaitingPhoneState.php
    │   │   │           └── InitialState.php
    │   │   └── Prompts/
    │   │       ├── AttendantPrompt.php
    │   │       ├── ConfirmationAttendantPrompt.php
    │   │       ├── EntityExtractorPrompt.php
    │   │       ├── ExistingAppointmentActionPrompt.php
    │   │       ├── ExistingAppointmentIntentPrompt.php
    │   │       ├── ExtractAppointmentManagementIntentPrompt.php
    │   │       ├── ExtractCorrectionPrompt.php
    │   │       ├── ExtractDateTimePrompt.php
    │   │       ├── ExtractFilterCriteriaPrompt.php
    │   │       ├── ExtractLocationPrompt.php
    │   │       ├── FilterUnitsPrompt.php
    │   │       ├── FunctionResponseFormatterPrompt.php
    │   │       ├── GeneralIntentPrompt.php
    │   │       ├── IsAffirmativePrompt.php
    │   │       ├── IsNegativePrompt.php
    │   │       ├── IsQuestionPrompt.php
    │   │       ├── OrchestrationPrompt.php
    │   │       ├── OrchestratorPrompt.php
    │   │       ├── ScopeCheckPrompt.php
    │   │       ├── SentimentAnalysisPrompt.php
    │   │       └── UnitChoicePrompt.php
    │   ├── Data/
    │   │   ├── ConversationAnalysisDTO.php
    │   │   ├── EntityExtractionDTO.php
    │   │   └── LocationDTO.php
    │   ├── Events/
    │   │   └── ChatMessageSent.php
    │   ├── Http/
    │   │   └── Controllers/
    │   │       ├── ApiChatController.php
    │   │       ├── Controller.php
    │   │       ├── WebChatController.php
    │   │       └── WebhookController.php
    │   ├── Jobs/
    │   │   └── ProcessChatMessage.php
    │   ├── Models/
    │   │   ├── ChatSession.php
    │   │   └── User.php
    │   ├── Providers/
    │   │   ├── AppServiceProvider.php
    │   │   ├── ChatbotServiceProvider.php
    │   │   └── TelescopeServiceProvider.php
    │   └── Services/
    │       ├── GoogleMapsService.php
    │       └── SchedulingService.php
    ├── bootstrap/
    │   ├── app.php
    │   ├── providers.php
    │   └── cache/
    │       ├── packages.php
    │       └── services.php
    ├── config/
    │   ├── app.php
    │   ├── auth.php
    │   ├── broadcasting.php
    │   ├── cache.php
    │   ├── database.php
    │   ├── filesystems.php
    │   ├── logging.php
    │   ├── mail.php
    │   ├── prism.php
    │   ├── queue.php
    │   ├── reverb.php
    │   ├── sanctum.php
    │   ├── services.php
    │   ├── session.php
    │   └── telescope.php
    ├── database/
    │   ├── factories/
    │   │   └── UserFactory.php
    │   ├── migrations/
    │   │   ├── 0001_01_01_000000_create_users_table.php
    │   │   ├── 0001_01_01_000001_create_cache_table.php
    │   │   ├── 0001_01_01_000002_create_jobs_table.php
    │   │   ├── 2025_08_06_130530_create_personal_access_tokens_table.php
    │   │   ├── 2025_08_07_202400_create_telescope_entries_table.php
    │   │   ├── 2025_08_07_210021_modify_users_table_for_nullable_email.php
    │   │   ├── 2025_08_08_125847_create_chat_sessions_table.php
    │   │   ├── 2025_08_26_203428_add_history_to_chat_sessions.php
    │   │   ├── 2025_09_01_153819_alter_table_chat_sessions_column_last_sentiment.php
    │   │   └── 2025_09_01_155925_alter_table_chat_sessions_column_summary.php
    │   └── seeders/
    │       └── DatabaseSeeder.php
    ├── docker/
    │   └── nginx/
    │       └── default.conf
    ├── public/
    │   ├── index.php
    │   ├── robots.txt
    │   └── .htaccess
    ├── resources/
    │   ├── css/
    │   │   └── app.css
    │   ├── js/
    │   │   ├── app.js
    │   │   └── bootstrap.js
    │   └── views/
    │       └── webchat.blade.php
    ├── routes/
    │   ├── api.php
    │   ├── channels.php
    │   ├── console.php
    │   └── web.php
    ├── storage/
    │   └── framework/
    │       └── views/
    │           └── fea62ea78877c7118eb545507523b1e3.php
    ├── streamlit/
    │   ├── Dockerfile
    │   ├── requirements.txt
    │   └── streamlit_chat.py
    └── tests/
        ├── TestCase.php
        ├── Feature/
        │   └── ExampleTest.php
        └── Unit/
            └── ExampleTest.php

================================================
FILE: README.md
================================================
# Chatbot Project

This is a chatbot application built with Laravel. It is designed to handle conversations with users, understand their intentions, and perform actions based on their requests. The chatbot is capable of handling appointment bookings, checking existing appointments, and engaging in general conversation.

## Features

- **Conversational Interface**: Engage in natural conversations with users.
- **Intent Recognition**: Understand the user's intent (e.g., booking, inquiry, greeting).
- **Appointment Booking**: Schedule new appointments for users.
- **Existing Appointment Management**: Check, modify, or cancel existing appointments.
- **Multi-platform**: Can be integrated with web and WhatsApp.
- **Extensible**: New functionalities can be easily added.

## Technologies

- **Backend**: Laravel 12
- **Database**: MySQL 8.0
- **Caching**: Redis 6.2
- **Web Server**: Nginx 1.19
- **Containerization**: Docker
- **Real-time Communication**: Laravel Reverb
- **Frontend (for chat interface)**: Streamlit

## Installation

1. **Clone the repository:**
   ```sh
   git clone https://github.com/your-username/your-repository.git
   cd your-repository
   ```

2. **Create the `.env` file:**
   ```sh
   cp .env.example .env
   ```
   > **Note:** You may need to update the environment variables in the `.env` file to match your local setup.

3. **Build and run the Docker containers:**
   ```sh
   docker-compose up -d --build
   ```

4. **Install Composer dependencies:**
   ```sh
   docker-compose exec app composer install
   ```

5. **Generate the application key:**
   ```sh
   docker-compose exec app php artisan key:generate
   ```

6. **Run database migrations:**
   ```sh
   docker-compose exec app php artisan migrate
   ```

## Services

The `docker-compose.yml` file defines the following services:

- **app**: The main Laravel application container.
- **nginx**: The Nginx web server that serves the application.
- **db**: The MySQL database container.
- **redis**: The Redis container for caching and queueing.
- **reverb**: The Laravel Reverb server for real-time WebSocket communication.
- **worker**: A dedicated container to run the Laravel queue worker.
- **streamlit**: A container for the Streamlit chat interface.



================================================
FILE: artisan
================================================
#!/usr/bin/env php
<?php

use Illuminate\Foundation\Application;
use Symfony\Component\Console\Input\ArgvInput;

define('LARAVEL_START', microtime(true));

// Register the Composer autoloader...
require __DIR__.'/vendor/autoload.php';

// Bootstrap Laravel and handle the command...
/** @var Application $app */
$app = require_once __DIR__.'/bootstrap/app.php';

$status = $app->handleCommand(new ArgvInput);

exit($status);



================================================
FILE: composer.json
================================================
{
    "$schema": "https://getcomposer.org/schema.json",
    "name": "laravel/laravel",
    "type": "project",
    "description": "The skeleton application for the Laravel framework.",
    "keywords": ["laravel", "framework"],
    "license": "MIT",
    "require": {
        "php": "^8.2",
        "laravel/framework": "^12.0",
        "laravel/reverb": "^1.5",
        "laravel/sanctum": "^4.0",
        "laravel/telescope": "^5.11",
        "laravel/tinker": "^2.10.1",
        "predis/predis": "^3.2",
        "prism-php/prism": "^0.97.0",
        "spatie/laravel-data": "^4.17"
    },
    "require-dev": {
        "fakerphp/faker": "^1.23",
        "laravel/pail": "^1.2.2",
        "laravel/pint": "^1.13",
        "laravel/sail": "^1.41",
        "mockery/mockery": "^1.6",
        "nunomaduro/collision": "^8.6",
        "phpunit/phpunit": "^11.5.3"
    },
    "autoload": {
        "psr-4": {
            "App\\": "app/",
            "Database\\Factories\\": "database/factories/",
            "Database\\Seeders\\": "database/seeders/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Tests\\": "tests/"
        }
    },
    "scripts": {
        "post-autoload-dump": [
            "Illuminate\\Foundation\\ComposerScripts::postAutoloadDump",
            "@php artisan package:discover --ansi"
        ],
        "post-update-cmd": [
            "@php artisan vendor:publish --tag=laravel-assets --ansi --force"
        ],
        "post-root-package-install": [
            "@php -r \"file_exists('.env') || copy('.env.example', '.env');\""
        ],
        "post-create-project-cmd": [
            "@php artisan key:generate --ansi",
            "@php -r \"file_exists('database/database.sqlite') || touch('database/database.sqlite');\"",
            "@php artisan migrate --graceful --ansi"
        ],
        "dev": [
            "Composer\\Config::disableProcessTimeout",
            "npx concurrently -c \"#93c5fd,#c4b5fd,#fb7185,#fdba74\" \"php artisan serve\" \"php artisan queue:listen --tries=1\" \"php artisan pail --timeout=0\" \"npm run dev\" --names=server,queue,logs,vite"
        ],
        "test": [
            "@php artisan config:clear --ansi",
            "@php artisan test"
        ]
    },
    "extra": {
        "laravel": {
            "dont-discover": []
        }
    },
    "config": {
        "optimize-autoloader": true,
        "preferred-install": "dist",
        "sort-packages": true,
        "allow-plugins": {
            "pestphp/pest-plugin": true,
            "php-http/discovery": true
        }
    },
    "minimum-stability": "stable",
    "prefer-stable": true
}



================================================
FILE: docker-compose.yml
================================================
services:
  # ... (serviços app, nginx, db, redis sem alterações) ...

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: chatbot-app
    restart: unless-stopped
    working_dir: /var/www/html
    volumes:
      - ./:/var/www/html
    networks:
      - chatbot-network

  nginx:
    image: nginx:1.19-alpine
    container_name: chatbot-nginx
    restart: unless-stopped
    ports:
      - "8000:80"
    volumes:
      - ./:/var/www/html
      - ./docker/nginx/default.conf:/etc/nginx/conf.d/default.conf
    networks:
      - chatbot-network
    depends_on:
      - app

  db:
    image: mysql:8.0
    container_name: chatbot-db
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE:-laravel}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD:-root}
      MYSQL_PASSWORD: ${DB_PASSWORD:-root}
      MYSQL_USER: ${DB_USERNAME:-user}
    volumes:
      - ./docker/dbdata:/var/lib/mysql
    ports:
      - "33066:3306"
    networks:
      - chatbot-network

  redis:
    image: redis:6.2-alpine
    container_name: chatbot-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    networks:
      - chatbot-network
  
  # NOVO: Serviço para o servidor Laravel Reverb
  reverb:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: chatbot-reverb
    restart: unless-stopped
    # O comando para iniciar o servidor Reverb
    command: "php artisan reverb:start --host=0.0.0.0 --port=8080"
    working_dir: /var/www/html
    ports:
      - "8080:8080" # Expõe a porta do WebSocket
    volumes:
      - ./:/var/www/html
    networks:
      - chatbot-network
    depends_on:
      - app
      - redis

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: chatbot-worker
    restart: unless-stopped
    command: "php artisan queue:work redis --sleep=3 --tries=3"
    working_dir: /var/www/html
    volumes:
      - ./:/var/www/html
    networks:
      - chatbot-network
    depends_on:
      - app
      - redis

  streamlit:
    build:
      context: ./streamlit
      dockerfile: Dockerfile
    container_name: chatbot-streamlit
    restart: unless-stopped
    ports:
      - "8501:8501"
    volumes:
      - ./streamlit:/app
    networks:
      - chatbot-network
    depends_on:
      - app

networks:
  chatbot-network:
    driver: bridge



================================================
FILE: Dockerfile
================================================
# Dockerfile
# Usa uma construção multi-estágio para criar o projeto Laravel sem precisar do Composer localmente.

# --- Estágio 1: Builder ---
# Usa a imagem do Composer para criar o projeto Laravel em um diretório temporário.
FROM composer:2.5 as builder
WORKDIR /app
# O comando abaixo garante que a versão mais recente e estável do Laravel seja instalada.
RUN composer create-project --prefer-dist laravel/laravel .

# --- Estágio 2: Aplicação Final ---
# Atualizado para usar a imagem do PHP 8.4 com FPM.
FROM php:8.4-fpm

# Define o diretório de trabalho
WORKDIR /var/www/html

# Instala dependências do sistema necessárias para as extensões do PHP
RUN apt-get update && apt-get install -y \
    build-essential \
    libpng-dev \
    libjpeg62-turbo-dev \
    libfreetype6-dev \
    locales \
    zip \
    jpegoptim optipng pngquant gifsicle \
    vim \
    unzip \
    git \
    curl \
    libzip-dev \
    # Dependência para a extensão Redis
    libhiredis-dev

# Limpa o cache do apt
RUN apt-get clean && rm -rf /var/lib/apt/lists/*

# Instala as extensões do PHP
RUN docker-php-ext-configure gd --with-freetype --with-jpeg \
    && docker-php-ext-install pdo_mysql zip bcmath gd

RUN docker-php-ext-configure pcntl --enable-pcntl \
    && docker-php-ext-install pcntl

# Instala a extensão Redis
RUN pecl install -o -f redis \
    && docker-php-ext-enable redis
# Instala o Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Copia os arquivos da aplicação
COPY --from=builder /app .

# **INÍCIO DA ALTERAÇÃO**
# Copia o arquivo .env para que os comandos artisan possam conectar-se à base de dados
COPY .env.example .env

# Gera a chave da aplicação
RUN php artisan key:generate

# Instala o Telescope e executa as migrações
# O --force é usado para executar as migrações em ambiente de produção/não interativo
#RUN php artisan migrate --force
#RUN php artisan telescope:install
# **FIM DA ALTERAÇÃO**

# Define as permissões corretas para o diretório de armazenamento e cache
RUN chown -R www-data:www-data /var/www/html/storage /var/www/html/bootstrap/cache
RUN chmod -R 775 /var/www/html/storage /var/www/html/bootstrap/cache

# Expõe a porta 9000 e inicia o PHP-FPM
EXPOSE 9000
CMD ["php-fpm"]



================================================
FILE: estrutura_chat_sessions.txt
================================================
Field       |Type        |Null|Key|Default|Extra|
------------+------------+----+---+-------+-----+
id          |char(36)    |NO  |PRI|       |     |
phone_number|varchar(255)|YES |MUL|       |     |
state       |json        |YES |   |       |     |
history     |json        |YES |   |       |     |
created_at  |timestamp   |YES |   |       |     |
updated_at  |timestamp   |YES |   |       |     |


================================================
FILE: package.json
================================================
{
    "$schema": "https://json.schemastore.org/package.json",
    "private": true,
    "type": "module",
    "scripts": {
        "build": "vite build",
        "dev": "vite"
    },
    "devDependencies": {
        "@tailwindcss/vite": "^4.0.0",
        "axios": "^1.8.2",
        "concurrently": "^9.0.1",
        "laravel-vite-plugin": "^2.0.0",
        "tailwindcss": "^4.0.0",
        "vite": "^7.0.4"
    }
}



================================================
FILE: phpunit.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         colors="true"
>
    <testsuites>
        <testsuite name="Unit">
            <directory>tests/Unit</directory>
        </testsuite>
        <testsuite name="Feature">
            <directory>tests/Feature</directory>
        </testsuite>
    </testsuites>
    <source>
        <include>
            <directory>app</directory>
        </include>
    </source>
    <php>
        <env name="APP_ENV" value="testing"/>
        <env name="APP_MAINTENANCE_DRIVER" value="file"/>
        <env name="BCRYPT_ROUNDS" value="4"/>
        <env name="CACHE_STORE" value="array"/>
        <env name="DB_CONNECTION" value="sqlite"/>
        <env name="DB_DATABASE" value=":memory:"/>
        <env name="MAIL_MAILER" value="array"/>
        <env name="QUEUE_CONNECTION" value="sync"/>
        <env name="SESSION_DRIVER" value="array"/>
        <env name="PULSE_ENABLED" value="false"/>
        <env name="TELESCOPE_ENABLED" value="false"/>
        <env name="NIGHTWATCH_ENABLED" value="false"/>
    </php>
</phpunit>



================================================
FILE: vite.config.js
================================================
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
    plugins: [
        laravel({
            input: ['resources/css/app.css', 'resources/js/app.js'],
            refresh: true,
        }),
        tailwindcss(),
    ],
});



================================================
FILE: .editorconfig
================================================
root = true

[*]
charset = utf-8
end_of_line = lf
indent_size = 4
indent_style = space
insert_final_newline = true
trim_trailing_whitespace = true

[*.md]
trim_trailing_whitespace = false

[*.{yml,yaml}]
indent_size = 2

[docker-compose.yml]
indent_size = 4



================================================
FILE: .env.example
================================================
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:sooe8JWibgxp6SNK0aVmOZTiC57cuIQrMOxV65d75Sw=
APP_DEBUG=true
APP_URL=http://localhost

APP_LOCALE=pt_BR
APP_FALLBACK_LOCALE=pt_BR
APP_FAKER_LOCALE=pt_BR

APP_MAINTENANCE_DRIVER=file
# APP_MAINTENANCE_STORE=database

PHP_CLI_SERVER_WORKERS=4

BCRYPT_ROUNDS=12

LOG_CHANNEL=stack
LOG_STACK=single
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
DB_HOST=db
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=user
DB_PASSWORD=root

SESSION_DRIVER=redis
SESSION_CONNECTION=default
SESSION_LIFETIME=120
SESSION_ENCRYPT=false
SESSION_PATH=/
SESSION_DOMAIN=null

BROADCAST_CONNECTION=reverb
FILESYSTEM_DISK=local
QUEUE_CONNECTION=redis

CACHE_STORE=redis
# CACHE_PREFIX=

MEMCACHED_HOST=127.0.0.1

REDIS_CLIENT=phpredis
REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=log
MAIL_SCHEME=null
MAIL_HOST=127.0.0.1
MAIL_PORT=2525
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

#VITE_APP_NAME="${APP_NAME}"
#VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
#VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
#VITE_PUSHER_HOST="${PUSHER_HOST}"
#VITE_PUSHER_PORT="${PUSHER_PORT}"
#VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"

OPENAI_API_KEY=
OPENAI_MODEL=gpt-4.1-mini

AI_ADAPTER=chatgpt
MESSAGING_ADAPTER=web


WHATSAPP_TOKEN=seu_token_aqui
WHATSAPP_PHONE_NUMBER_ID=seu_id_de_numero_de_telefone_aqui


SCHEDULING_API_BASE_URL=https://www.psdsaopaulo.net.br/psd2/laravel/public/api
SCHEDULING_API_TOKEN=7f7d600bf2923edb35edc3ce4927e6842b22add26d204bf782344891cf718b8d

REVERB_APP_ID=624633
REVERB_APP_KEY=eu5sgudkyypngdki4iyl
REVERB_APP_SECRET=b2vtukumdiezzyycql0c
REVERB_HOST="reverb"
REVERB_PORT=8080
REVERB_SCHEME=http

VITE_REVERB_APP_KEY="${REVERB_APP_KEY}"
VITE_REVERB_HOST="${REVERB_HOST}"
VITE_REVERB_PORT="${REVERB_PORT}"
VITE_REVERB_SCHEME="${REVERB_SCHEME}"

PUSHER_APP_ID=1234
PUSHER_APP_KEY=7f7d600bf2923edb35edc3ce4927e6842b22add26d204bf782344891cf718b8d
PUSHER_APP_SECRET=batata
PUSHER_APP_CLUSTER=mt1


================================================
FILE: app/Adapters/Ai/AiAdapterInterface.php
================================================
<?php

namespace App\Adapters\Ai;

interface AiAdapterInterface
{
    /**
     * Obtém uma resposta de chat do provedor de IA.
     *
     * @param string $prompt O prompt principal (mensagem do sistema ou instrução).
     * @param array $history O histórico da conversa (array de arrays associativos).
     * @param bool $expect_json Define se a resposta DEVE ser um JSON.
     * @return string A resposta em texto da IA (seja texto simples ou uma string JSON).
     */
    public function getChat(string $prompt, array $history = [], bool $expect_json = false): string;
}



================================================
FILE: app/Adapters/Ai/ChatGPTAdapter.php
================================================
<?php

namespace App\Adapters\Ai;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

/**
 * Class ChatGPTAdapter
 *
 * Implementação do AiAdapterInterface para o serviço ChatGPT da OpenAI.
 */
class ChatGPTAdapter implements AiAdapterInterface
{
    protected string $apiKey;
    protected string $apiUrl = 'https://api.openai.com/v1/chat/completions';
    protected string $model;

    public function __construct()
    {
        $this->apiKey = config('services.openai.api_key');
        $this->model = config('services.openai.model', 'gpt-4.1-mini');
    }

    /**
     * Envia um prompt para a API do ChatGPT e retorna a resposta.
     *
     * @param string $prompt O prompt completo a ser enviado para a IA.
     * @param string $sessionId O ID da sessão (não usado diretamente pelo ChatGPT neste modelo simples, mas necessário para cumprir a interface).
     * @param array $context O histórico da conversa.
     * @return string A resposta de texto gerada pela IA.
     */
    public function getChat(string $prompt, string $sessionId, array $context = []): string
    {
        if (empty($this->apiKey)) {
            Log::error('OpenAI API key não está configurada.');
            return 'Erro de configuração: A chave da API não foi definida.';
        }

        $messages = $context;
        $messages[] = ['role' => 'user', 'content' => $prompt];

        $payload = [
            'model' => $this->model,
            'messages' => $messages,
            'response_format' => ['type' => 'json_object'],
        ];

        $response = Http::withToken($this->apiKey)
            ->timeout(60)
            ->post($this->apiUrl, $payload);

        if ($response->successful()) {
            return $response->json('choices.0.message.content', '{"intent": "desconhecida", "confidence": 0.0}');
        }

        Log::error('Falha na API da OpenAI: ' . $response->body(), [
            'status' => $response->status(),
            'payload_sent' => $payload
        ]);

        return 'Desculpe, não consegui processar sua solicitação no momento. Tente novamente mais tarde.';
    }
}



================================================
FILE: app/Adapters/Ai/PrismAdapter.php
================================================
<?php

namespace App\Adapters\Ai;

use Prism\Prism\Facades\Prism;
use Prism\Prism\Enums\Provider;

class PrismAdapter implements AiAdapterInterface
{
    public function getChat(string $prompt, array $history = [], bool $expect_json = false): string
    {
        // Constrói a chamada base do Prism
        // Você pode tornar o provedor e o modelo configuráveis (via config/prism.php)
        $chat = Prism::text()
            ->using(Provider::OpenAI, 'gpt-4o') // Ou qualquer modelo que preferir
            ->withSystemPrompt($prompt);

        // Adiciona o histórico, se houver
        if (!empty($history)) {
            // O Prism pode precisar que o histórico seja formatado
            // (ex: $chat->withHistory($this->formatHistory($history)))
            // Por enquanto, vamos assumir que `withMessages` funcione
            // Nota: Verifique a documentação do Prism para a melhor forma de
            // injetar o histórico (ex: `->withMessages([...])`)
            $chat->withMessages($history); // Ajuste conforme a API do Prism
        }

        if ($expect_json) {
            // É AQUI QUE O PRISM RESOLVE SEU PROBLEMA
            // Ele lidará com a formatação da requisição para forçar um JSON
            $response = $chat->asJson();
            return $response->content(); // ou $response->json()
        }

        // Para texto simples (ex: "sim", "não")
        $response = $chat->asText();
        return $response->text(); // ou $response->content()
    }

    /*
    // Você pode precisar de um helper para formatar o histórico
    // para o formato que o Prism espera
    private function formatHistory(array $history): array
    {
        $formatted = [];
        foreach ($history as $message) {
            if ($message['role'] === 'user') {
                $formatted[] = \Prism\Prism\Messages\UserMessage::from($message['content']);
            } elseif ($message['role'] === 'model') {
                $formatted[] = \Prism\Prism\Messages\AssistantMessage::from($message['content']);
            }
        }
        return $formatted;
    }
    */
}



================================================
FILE: app/Adapters/Messaging/MessagingAdapterInterface.php
================================================
<?php

namespace App\Adapters\Messaging;

use Illuminate\Http\Request;

/**
 * Interface MessagingAdapterInterface
 *
 * Define o contrato para os adaptadores de plataformas de mensagens.
 * Cada adaptador será responsável por "traduzir" os dados de uma plataforma específica
 * (como WhatsApp, Telegram) para um formato padronizado que nossa aplicação entende,
 * e também por enviar as respostas de volta para a plataforma de origem.
 */
interface MessagingAdapterInterface
{
    /**
     * Processa a requisição de entrada (webhook) e extrai informações relevantes.
     *
     * @param Request $request A requisição HTTP recebida do webhook da plataforma.
     * @return array Deve retornar um array padronizado com os dados da mensagem.
     * Exemplo: ['senderId' => '123456789', 'message' => 'Olá, mundo!']
     */
    public function processIncoming(Request $request): array;

    /**
     * Envia uma mensagem de resposta para o usuário na plataforma de origem.
     *
     * @param string $recipientId O identificador único do destinatário na plataforma.
     * @param string $message A mensagem de texto a ser enviada.
     * @return bool Retorna true em caso de sucesso no envio, false caso contrário.
     */
    public function sendResponse(string $recipientId, string $message): bool;
}



================================================
FILE: app/Adapters/Messaging/WebAdapter.php
================================================
<?php

namespace App\Adapters\Messaging;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Session;

/**
 * Class WebAdapter
 *
 * Adaptador para interação via interface web local.
 * Utiliza a sessão do Laravel para armazenar o histórico da conversa.
 */
class WebAdapter implements MessagingAdapterInterface
{
    /**
     * Processa a requisição vinda do formulário web.
     */
    public function processIncoming(Request $request): array
    {
        // Para a web, o senderId pode ser o ID da sessão para simular um usuário único.
        $senderId = Session::getId();
        $message = $request->input('message');

        // Adiciona a mensagem do usuário ao histórico da sessão.
        Session::push('chat_history', ['sender' => 'user', 'message' => $message]);

        return [
            'senderId' => $senderId,
            'message' => $message,
        ];
    }

    /**
     * "Envia" a resposta adicionando-a ao histórico da sessão.
     */
    public function sendResponse(string $recipientId, string $message): bool
    {
        // Adiciona a resposta do bot ao histórico da sessão.
        Session::push('chat_history', ['sender' => 'bot', 'message' => $message]);
        return true;
    }
}



================================================
FILE: app/Adapters/Messaging/WhatsAppAdapter.php
================================================
<?php

namespace App\Adapters\Messaging;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

/**
 * Class WhatsAppAdapter
 *
 * Adaptador para a API do WhatsApp Cloud.
 */
class WhatsAppAdapter implements MessagingAdapterInterface
{
    protected string $token;
    protected string $phone_numberId;
    protected string $apiUrl;

    /**
     * Carrega as configurações da API do WhatsApp.
     */
    public function __construct()
    {
        $this->token = config('services.whatsapp.token');
        $this->phone_numberId = config('services.whatsapp.phone_number_id');
        $this->apiUrl = "https://graph.facebook.com/v19.0/{$this->phone_numberId}/messages";
    }

    /**
     * Processa a requisição de entrada do webhook do WhatsApp.
     *
     * @param Request $request
     * @return array
     */
    public function processIncoming(Request $request): array
    {
        // Extrai a mensagem de texto do payload do webhook.
        $message = $request->input('entry.0.changes.0.value.messages.0.text.body');
        $senderId = $request->input('entry.0.changes.0.value.messages.0.from');

        if (!$message || !$senderId) {
            // Se não for uma mensagem de texto válida, retorna um array vazio.
            return [];
        }

        return [
            'senderId' => $senderId,
            'message' => $message,
        ];
    }

    /**
     * Envia uma mensagem de resposta para o usuário via WhatsApp.
     *
     * @param string $recipientId O número de telefone do destinatário.
     * @param string $message A mensagem a ser enviada.
     * @return bool
     */
    public function sendResponse(string $recipientId, string $message): bool
    {
        if (empty($this->token) || empty($this->phone_numberId)) {
            Log::error('Configurações do WhatsApp não definidas (token ou phone_number_id).');
            return false;
        }

        $payload = [
            'messaging_product' => 'whatsapp',
            'to' => $recipientId,
            'text' => ['body' => $message],
        ];

        $response = Http::withToken($this->token)->post($this->apiUrl, $payload);

        if ($response->failed()) {
            Log::error('Falha ao enviar mensagem pelo WhatsApp: ' . $response->body());
            return false;
        }

        return true;
    }
}



================================================
FILE: app/Chat/ChatApplicationManager.php
================================================
<?php

namespace App\Chat;

use App\Chat\Applications\BookingApplication;
use App\Chat\Applications\ExistingAppointmentApplication;
use App\Chat\Contracts\ChatApplicationInterface;
use App\Models\ChatSession;
use Illuminate\Contracts\Container\Container;
use Illuminate\Support\Facades\Log;

class ChatApplicationManager
{
    protected Container $container;
    protected ConversationAnalyzerService $conversation_analyzer;

    public function __construct(Container $container, ConversationAnalyzerService $conversation_analyzer)
    {
        $this->container = $container;
        $this->conversation_analyzer = $conversation_analyzer;
    }

    public function handle(ChatSession $session, string $message, string $channel): ?string
    {
        Log::info('[Manager] Iniciando handle', ['session_id' => $session->id, 'message' => $message]);

        // Prioridade 1: Manter o fluxo de uma aplicação de MÚLTIPLOS PASSOS já ativa.
        $active_app = $this->getActiveStatefulApplication($session);
        if ($active_app) {
            $app_name = get_class($active_app);
            Log::info("[Manager] Aplicação com estado ativa encontrada: {$app_name}. Delegando o controle.");
            return $active_app->handle($message, $session);
        }

        // Prioridade 2: Orquestrar uma nova intenção se nenhum fluxo estiver ativo.
        $analysis = $this->conversation_analyzer->analyze($message, $session);
        Log::info("[Manager] Intenção classificada pelo orquestrador: {$analysis->intent}");

        $application = $this->getApplicationForIntent($analysis->intent);

        if ($application) {
            $app_name = get_class($application);
            Log::info("[Manager] Aplicação correspondente à intenção encontrada: {$app_name}.");
            return $application->handle($message, $session);
        }

        Log::warning('[Manager] Nenhuma aplicação foi encontrada para tratar a intenção.', [
            'intent' => $analysis->intent,
            'message' => $message
        ]);
        return 'Desculpe, não entendi. Eu posso te ajudar a agendar, consultar ou cancelar uma avaliação. Como posso prosseguir?';
    }

    /**
     * Verifica se existe um fluxo de múltiplos passos ativo na sessão.
     * Aplicações sem estado (como saudação) são ignoradas aqui.
     */
    protected function getActiveStatefulApplication(ChatSession $session): ?ChatApplicationInterface
    {
        $flow = $session->state['flow'] ?? null;

        // Mapeia os nomes dos fluxos que devem persistir entre as mensagens.
        $stateful_flows = [
            'booking' => BookingApplication::class,
            'existing_appointment' => ExistingAppointmentApplication::class,
        ];

        if ($flow && isset($stateful_flows[$flow])) {
            $class = $stateful_flows[$flow];
            if ($this->container->has($class)) {
                return $this->container->make($class);
            }
        }

        return null;
    }

    /**
     * Mapeia uma intenção para a classe de aplicação correspondente.
     */
    protected function getApplicationForIntent(string $intent): ?ChatApplicationInterface
    {
        // Mapeia todas as intenções, incluindo as de passo único.
        $intent_map = [
            'agendamento' => \App\Chat\Applications\BookingApplication::class,
            'consultar_agendamento' => \App\Chat\Applications\ExistingAppointmentApplication::class,
            'cancelamento' => \App\Chat\Applications\ExistingAppointmentApplication::class,
            'reagendamento' => \App\Chat\Applications\ExistingAppointmentApplication::class,
            'saudacao' => \App\Chat\Applications\GreetingApplication::class,
        ];

        $class = $intent_map[$intent] ?? null;

        if ($class && $this->container->has($class)) {
            return $this->container->make($class);
        }

        return null;
    }
}



================================================
FILE: app/Chat/ConversationAnalyzerService.php
================================================
<?php

namespace App\Chat;

use App\Adapters\Ai\AiAdapterInterface;
use App\Chat\Prompts\OrchestratorPrompt;
use App\Data\ConversationAnalysisDTO;
use App\Models\ChatSession;
use Illuminate\Support\Facades\Log;
use Spatie\LaravelData\Exceptions\InvalidDataException;
use PHPUnit\Framework\InvalidDataProviderException;

class ConversationAnalyzerService
{
    public function __construct(
        protected AiAdapterInterface $ai_adapter,
        protected OrchestratorPrompt $prompt
    ) {}

    public function analyze(string $message, ChatSession $session): ConversationAnalysisDTO
    {
        $history = $session->getFormattedHistory();
        $prompt_text = $this->prompt->build($message, $history);

        $raw_response = $this->ai_adapter->getChat($prompt_text, $history, true);

        $json_data = $this->extractJsonFromString($raw_response);

        if (!$json_data) {
            Log::error('[ConversationAnalyzerService] Não foi possível extrair JSON da resposta da IA.', [
                'session_id' => $session->id,
                'raw_response' => $raw_response,
            ]);
            return $this->fallbackResponse();
        }

        try {
            // DTO foi simplificado para corresponder à saída do Orquestrador
            return ConversationAnalysisDTO::from($json_data);
        } catch (InvalidDataException $e) {
            Log::error('[ConversationAnalyzerService] Resposta da IA inválida após a limpeza.', [
                'session_id' => $session->id,
                'raw_response' => $raw_response,
                'cleaned_json' => $json_data,
                'errors' => $e->errors(),
            ]);
            return $this->fallbackResponse();
        }
    }

    private function fallbackResponse(): ConversationAnalysisDTO
    {
        return new ConversationAnalysisDTO(
            intent: 'desconhecida',
            confidence: 0.0
        );
    }

    private function extractJsonFromString(string $string): ?array
    {
        preg_match('/```json\s*(\{.*?\})\s*```/s', $string, $matches);
        $json_string = $matches[1] ?? null;

        if (!$json_string) {
            preg_match('/```\s*(\{.*?\})\s*```/s', $string, $matches);
            $json_string = $matches[1] ?? null;
        }

        if (!$json_string) {
            $json_string = $string;
        }

        $data = json_decode(trim($json_string), true);

        return json_last_error() === JSON_ERROR_NONE ? $data : null;
    }
}



================================================
FILE: app/Chat/FunctionResponseFormatterService.php
================================================
<?php

namespace App\Chat;

use App\Adapters\Ai\AiAdapterInterface;
use App\Chat\Prompts\FunctionResponseFormatterPrompt;
use App\Models\ChatSession;

/**
 * Serviço para "traduzir" respostas de API em linguagem natural.
 */
class FunctionResponseFormatterService
{
    protected AiAdapterInterface $ai_adapter;
    protected FunctionResponseFormatterPrompt $prompt;

    public function __construct(AiAdapterInterface $ai_adapter, FunctionResponseFormatterPrompt $prompt)
    {
        $this->ai_adapter = $ai_adapter;
        $this->prompt = $prompt;
    }

    /**
     * Formata os dados brutos em uma resposta amigável.
     *
     * @param array $data Os dados da API.
     * @param ChatSession $session A sessão de chat.
     * @return string A resposta formatada.
     */
    public function format(array $data, ChatSession $session): string
    {
        $json_data = json_encode($data, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
        $history = $session->getFormattedHistory();

        $prompt_text = $this->prompt->build($json_data, $history);

        // O adapter de IA precisa ser configurado com o prompt de sistema do "ATENDENTE"
        // para manter a persona correta ao gerar a resposta.
        $system_prompt = app(Prompts\AttendantPrompt::class)->build();

        return $this->ai_adapter->getChat($prompt_text, $session->id, [], $system_prompt);
    }
}



================================================
FILE: app/Chat/GeneralIntentClassifier.php
================================================
<?php

namespace App\Chat;

use App\Adapters\Ai\AiAdapterInterface;
use App\Chat\Prompts\GeneralIntentPrompt;
use Illuminate\Support\Facades\Log;

/**
 * Classifica a intenção geral de uma mensagem do utilizador usando um modelo de IA.
 */
class GeneralIntentClassifier
{
    protected AiAdapterInterface $ai;
    protected GeneralIntentPrompt $prompt;

    public function __construct(AiAdapterInterface $ai, GeneralIntentPrompt $prompt)
    {
        $this->ai = $ai;
        $this->prompt = $prompt;
    }

    /**
     * Usa o adaptador de IA para classificar a intenção da mensagem.
     *
     * @param string $message A mensagem do utilizador.
     * @param string $sessionId O ID da sessão para manter o contexto.
     * @return string A intenção classificada.
     */
    public function classify(string $message, string $sessionId): string
    {
        Log::info('[GeneralIntentClassifier] Iniciando classificação de intenção.', [
            'session_id' => $sessionId,
            'message' => $message
        ]);

        $promptText = $this->prompt->build($message);
        $response = $this->ai->getChat($promptText, $sessionId);
        $intent = $this->parseIntentFromResponse($response);

        Log::info('[GeneralIntentClassifier] Classificação concluída.', [
            'session_id' => $sessionId,
            'raw_response' => $response,
            'parsed_intent' => $intent
        ]);

        return $intent;
    }

    /**
     * Analisa a resposta da IA para extrair a intenção.
     *
     * @param string $response A resposta bruta do modelo de IA.
     * @return string
     */
    protected function parseIntentFromResponse(string $response): string
    {
        $cleanedResponse = strtolower(trim($response));

        // CORRIGIDO: A lista de intenções válidas agora inclui todas as
        // possibilidades definidas no GeneralIntentPrompt.
        $validIntents = ['agendamento', 'cancelamento', 'informacao_geral', 'saudacao'];

        if (in_array($cleanedResponse, $validIntents)) {
            return $cleanedResponse;
        }

        Log::warning('[GeneralIntentClassifier] A resposta da IA não corresponde a uma intenção válida.', [
            'response' => $cleanedResponse,
            'valid_intents' => $validIntents
        ]);

        return 'unknown';
    }
}



================================================
FILE: app/Chat/IntentManager.php
================================================
<?php

namespace App\Chat;

use App\Adapters\Ai\AiAdapterInterface;
use App\Chat\Prompts\ExistingAppointmentIntentPrompt;
use App\Chat\Prompts\GeneralIntentPrompt;
use App\Chat\Prompts\ScopeCheckPrompt;
use Illuminate\Support\Str;

/**
 * Class IntentManager
 *
 * Responsável por analisar a mensagem do usuário e classificar sua intenção principal
 * utilizando o serviço de Inteligência Artificial configurado.
 */
class IntentManager
{
    protected AiAdapterInterface $ai_adapter;
    protected ExistingAppointmentIntentPrompt $existing_appointment_prompt;
    protected GeneralIntentPrompt $general_intent_prompt;
    protected ScopeCheckPrompt $scope_check_prompt;

    /**
     * Construtor da classe.
     */
    public function __construct(
        AiAdapterInterface $ai_adapter,
        ExistingAppointmentIntentPrompt $existing_appointment_prompt,
        GeneralIntentPrompt $general_intent_prompt,
        ScopeCheckPrompt $scope_check_prompt
    ) {
        $this->ai_adapter = $ai_adapter;
        $this->existing_appointment_prompt = $existing_appointment_prompt;
        $this->general_intent_prompt = $general_intent_prompt;
        $this->scope_check_prompt = $scope_check_prompt;
    }

    // MODIFICADO: Adicionado $sessionId para cumprir o contrato da interface
    public function getExistingAppointmentIntent(string $user_message, string $sessionId): string
    {
        $prompt = $this->existing_appointment_prompt->build($user_message);
        // MODIFICADO: Utiliza o método getChat
        return $this->normalizeIntent($this->ai_adapter->getChat($prompt, $sessionId));
    }

    // MODIFICADO: Adicionado $sessionId para cumprir o contrato da interface
    public function getIntent(string $user_message, string $sessionId): string
    {
        $prompt = $this->general_intent_prompt->build($user_message);
        // MODIFICADO: Utiliza o método getChat
        $intent = $this->ai_adapter->getChat($prompt, $sessionId);
        return $this->normalizeIntent($intent);
    }

    /**
     * Verifica se a mensagem do usuário está dentro do escopo de atendimento.
     *
     * @param string $user_message A mensagem do usuário.
     * @param string $sessionId O ID da sessão.
     * @return bool Retorna true se a mensagem for relevante, false caso contrário.
     */
    // MODIFICADO: Adicionado $sessionId para cumprir o contrato da interface
    public function isMessageOnTopic(string $user_message, string $sessionId): bool
    {
        if (in_array(strtolower(trim($user_message)), ['oi', 'ola', 'olá', 'bom dia', 'boa tarde', 'boa noite'])) {
            return true;
        }

        $prompt = $this->scope_check_prompt->build($user_message);
        // MODIFICADO: Utiliza o método getChat
        $response = $this->ai_adapter->getChat($prompt, $sessionId);
        return strtolower(trim($response)) === 'yes';
    }

    private function normalizeIntent(string $rawIntent): string
    {
        return Str::lower(trim($rawIntent, " \n\r\t\v\0."));
    }
}



================================================
FILE: app/Chat/PromptManager.php
================================================
<?php

namespace App\Chat;

use App\Adapters\Ai\AiAdapterInterface;
use App\Chat\Prompts\EntityExtractorPrompt;
use App\Data\EntityExtractionDTO;
use Illuminate\Support\Facades\Log;
use Spatie\LaravelData\Exceptions\InvalidDataException;
// ... existing use statements ...
use App\Chat\Prompts\ExistingAppointmentActionPrompt;
use App\Chat\Prompts\ExtractAppointmentManagementIntentPrompt;
use App\Chat\Prompts\ExtractCorrectionPrompt;
use App\Chat\Prompts\ExtractDateTimePrompt;
use App\Chat\Prompts\ExtractFilterCriteriaPrompt;
use App\Chat\Prompts\UnitChoicePrompt;


/**
 * Centraliza a lógica de construção de prompts e interação com a IA para extração de dados.
 */
class PromptManager
{
    protected AiAdapterInterface $ai_adapter;

    public function __construct(AiAdapterInterface $ai_adapter)
    {
        $this->ai_adapter = $ai_adapter;
    }

    /**
     * Usa o EntityExtractorPrompt para extrair várias entidades de uma mensagem.
     */
    public function extractEntities(string $message, string $session_id, string $history = ''): ?EntityExtractionDTO
    {
        $prompt = app(EntityExtractorPrompt::class)->build($message, $history);
        $response_json = $this->ai_adapter->getChat($prompt, $session_id);

        $data = json_decode(trim($response_json), true);

        if (json_last_error() !== JSON_ERROR_NONE) {
            Log::error('[PromptManager] Resposta da IA para extração de entidades não é um JSON válido.', [
                'session_id' => $session_id,
                'response' => $response_json
            ]);
            return null;
        }

        try {
            return EntityExtractionDTO::from($data);
        } catch (InvalidDataException $e) {
            Log::error('[PromptManager] Erro ao criar EntityExtractionDTO.', [
                'session_id' => $session_id,
                'data' => $data,
                'errors' => $e->errors()
            ]);
            return null;
        }
    }


    /**
     * Extrai a data e a hora da mensagem do usuário.
     */
    // ... existing code ...
    public function extractDateTime(string $message, string $session_id): ?array
    {
        $prompt = app(ExtractDateTimePrompt::class)->build($message);
        $response_json = $this->ai_adapter->getChat($prompt, $session_id);
        $data = json_decode(trim($response_json), true);

        return (json_last_error() === JSON_ERROR_NONE && !empty($data['date']) && !empty($data['time'])) ? $data : null;
    }

    /**
     * Identifica qual unidade o usuário escolheu de uma lista.
     */
    // ... existing code ...
    public function extractUnitChoice(string $message, array $units, string $session_id): ?array
    {
        $prompt = app(UnitChoicePrompt::class)->build($message, $units);
        $response_json = $this->ai_adapter->getChat($prompt, $session_id);
        $data = json_decode(trim($response_json), true);

        Log::info('[PromptManager] Resposta da IA para escolha de unidade.', ['response' => $data]);
        return (json_last_error() === JSON_ERROR_NONE) ? $data : null;
    }

    /**
     * Extrai qual campo o usuário deseja corrigir.
     */
    // ... existing code ...
    public function extractCorrectionField(string $message, string $session_id): string
    {
        $prompt = app(ExtractCorrectionPrompt::class)->build($message);
        $response = $this->ai_adapter->getChat($prompt, $session_id);
        return trim(strtolower($response));
    }

    /**
     * Extrai critérios de filtro de uma pergunta sobre unidades.
     */
    // ... existing code ...
    public function extractFilterCriteria(string $message, string $session_id): ?array
    {
        $prompt = app(ExtractFilterCriteriaPrompt::class)->build($message);
        $response_json = $this->ai_adapter->getChat($prompt, $session_id);
        $criteria = json_decode(trim($response_json), true);

        return (json_last_error() === JSON_ERROR_NONE && !empty(array_filter($criteria))) ? $criteria : null;
    }

    /**
     * Extrai a ação do usuário sobre um agendamento existente.
     */
    // ... existing code ...
    public function extractExistingAppointmentAction(string $message, string $session_id): string
    {
        $prompt = app(ExistingAppointmentActionPrompt::class)->build($message);
        $response_json = $this->ai_adapter->getChat($prompt, $session_id);
        $choice_data = json_decode(trim($response_json), true);
        return $choice_data['action'] ?? 'desconhecido';
    }

    /**
     * Extrai se a intenção é gerenciar um agendamento (confirmar, cancelar, reagendar).
     */
    // ... existing code ...
    public function extractAppointmentManagementIntent(string $message, string $session_id): string
    {
        $prompt = app(ExtractAppointmentManagementIntentPrompt::class)->build($message);
        $response = $this->ai_adapter->getChat($prompt, $session_id);
        $cleaned_response = trim(strtolower($response));

        if (in_array($cleaned_response, ['confirmar', 'cancelar', 'reagendar', 'nenhuma'])) {
            return $cleaned_response;
        }

        return 'nenhuma';
    }
}



================================================
FILE: app/Chat/ResponseAnalyzer.php
================================================
<?php

namespace App\Chat;

use App\Adapters\Ai\AiAdapterInterface;
use App\Chat\Prompts\IsAffirmativePrompt;
use App\Chat\Prompts\IsNegativePrompt;
use App\Chat\Prompts\IsQuestionPrompt;
use Illuminate\Support\Facades\Log;

/**
 * Analisa respostas curtas do utilizador para determinar a sua natureza (afirmativa, negativa, etc.).
 */
class ResponseAnalyzer
{
    protected AiAdapterInterface $ai;
    protected IsAffirmativePrompt $isAffirmativePrompt;
    protected IsNegativePrompt $isNegativePrompt;
    protected IsQuestionPrompt $isQuestionPrompt;

    public function __construct(
        AiAdapterInterface $ai,
        IsAffirmativePrompt $isAffirmativePrompt,
        IsNegativePrompt $isNegativePrompt,
        IsQuestionPrompt $isQuestionPrompt
    ) {
        $this->ai = $ai;
        $this->isAffirmativePrompt = $isAffirmativePrompt;
        $this->isNegativePrompt = $isNegativePrompt;
        $this->isQuestionPrompt = $isQuestionPrompt;
    }

    /**
     * Verifica se a mensagem é uma afirmação.
     *
     * @param string $message
     * @return bool
     */
    public function isAffirmative(string $message): bool
    {
        $prompt = $this->isAffirmativePrompt->build($message);
        $response = $this->ai->getChat($prompt, 'analyzer_affirmative');
        Log::info('[ResponseAnalyzer] Verificação afirmativa.', ['message' => $message, 'response' => $response]);
        return str_contains(strtolower($response), 'sim');
    }

    /**
     * Verifica se a mensagem é uma negação.
     *
     * @param string $message
     * @return bool
     */
    public function isNegative(string $message): bool
    {
        $prompt = $this->isNegativePrompt->build($message);
        $response = $this->ai->getChat($prompt, 'analyzer_negative');
        Log::info('[ResponseAnalyzer] Verificação negativa.', ['message' => $message, 'response' => $response]);
        return str_contains(strtolower($response), 'sim');
    }

    /**
     * Verifica se a mensagem é uma pergunta.
     *
     * @param string $message
     * @return bool
     */
    public function isAQuestion(string $message): bool
    {
        $prompt = $this->isQuestionPrompt->build($message);
        $response = $this->ai->getChat($prompt, 'analyzer_question');
        Log::info('[ResponseAnalyzer] Verificação de pergunta.', ['message' => $message, 'response' => $response]);
        return str_contains(strtolower($response), 'sim');
    }
}



================================================
FILE: app/Chat/SentimentAnalyzerService.php
================================================
<?php

namespace App\Chat;

use App\Adapters\Ai\AiAdapterInterface;
use App\Chat\Prompts\SentimentAnalysisPrompt;
use Illuminate\Support\Facades\Log;

/**
 * Serviço responsável por analisar e classificar o sentimento de uma mensagem.
 */
class SentimentAnalyzerService
{
    protected AiAdapterInterface $ai_adapter;
    protected SentimentAnalysisPrompt $prompt;

    public function __construct(AiAdapterInterface $ai_adapter, SentimentAnalysisPrompt $prompt)
    {
        $this->ai_adapter = $ai_adapter;
        $this->prompt = $prompt;
    }

    /**
     * Analisa a mensagem do usuário e retorna a classificação de sentimento.
     *
     * @param string $message A mensagem a ser analisada.
     * @param string $session_id O ID da sessão para logging.
     * @return string|null A etiqueta do sentimento ou nulo em caso de falha.
     */
    public function analyze(string $message, string $session_id): ?string
    {
        try {
            $prompt_text = $this->prompt->build($message);
            $raw_response = $this->ai_adapter->getChat($prompt_text, $session_id . '_sentiment');

            $json_data = json_decode(trim($raw_response), true);

            if (json_last_error() === JSON_ERROR_NONE && isset($json_data['label'])) {
                Log::info('[SentimentAnalyzerService] Sentimento classificado com sucesso.', [
                    'session_id' => $session_id,
                    'sentiment' => $json_data['label']
                ]);
                return $json_data['label'];
            }

            Log::warning('[SentimentAnalyzerService] Não foi possível decodificar o JSON da resposta de sentimento.', [
                'session_id' => $session_id,
                'raw_response' => $raw_response
            ]);
        } catch (\Exception $e) {
            Log::error('[SentimentAnalyzerService] Exceção ao analisar sentimento.', [
                'session_id' => $session_id,
                'error' => $e->getMessage()
            ]);
        }

        return null;
    }
}



================================================
FILE: app/Chat/Applications/BookingApplication.php
================================================
<?php

namespace App\Chat\Applications;

use App\Adapters\Ai\AiAdapterInterface;
use App\Chat\Contracts\ChatApplicationInterface;
use App\Chat\Flows\BookingFlowManager;
use App\Models\ChatSession;
use App\Services\SchedulingService;
use Illuminate\Support\Facades\Log;

class BookingApplication implements ChatApplicationInterface
{
    protected AiAdapterInterface $ai_adapter;
    protected SchedulingService $scheduling_service;
    protected bool $unidades_disponiveis = true;

    public function __construct(AiAdapterInterface $ai_adapter, SchedulingService $scheduling_service)
    {
        $this->ai_adapter = $ai_adapter;
        $this->scheduling_service = $scheduling_service;
    }

    public function shouldHandle(string $message, ChatSession $session): bool
    {
        Log::info('[BookingApplication] Verificando se deve manipular a mensagem.');

        $unidades = $this->scheduling_service->getUnidades();
        if (empty($unidades)) {
            Log::warning('[BookingApplication] Cache de unidades vazio. O serviço está indisponível.');
            $this->unidades_disponiveis = false;
            // Mesmo indisponível, deve manipular para informar o usuário.
            return true;
        }

        $state = $session->state ?? [];
        if (($state['flow'] ?? null) === 'booking') {
            Log::info('[BookingApplication] Sessão já está no fluxo de agendamento.');
            return true;
        }

        $prompt = "A mensagem do usuário demonstra a intenção de agendar, marcar, reservar ou verificar a disponibilidade de um serviço? Responda apenas com 'sim' ou 'não'. Mensagem: \"$message\"";
        $response = trim(strtolower($this->ai_adapter->getChat($prompt, $session->id)));

        $should_handle = $response === 'sim';
        Log::info('[BookingApplication] Verificação de intenção de agendamento.', ['response' => $response, 'should_handle' => $should_handle]);

        return $should_handle;
    }

    public function handle(string $message, ChatSession $session): string
    {
        Log::info('[BookingApplication] Manipulando a mensagem.');

        if (!$this->unidades_disponiveis) {
            return "Peço desculpas, mas nosso sistema de agendamento está temporariamente indisponível. Por favor, tente novamente mais tarde.";
        }

        $state = $session->state ?? [];
        // Inicia o fluxo de agendamento se ainda não estiver nele.
        if (($state['flow'] ?? null) !== 'booking') {
            $state['flow'] = 'booking';
            // O estado inicial do fluxo é definido pelo próprio manipulador de estado.
            unset($state['flow_state']);
            $session->state = $state;
            $session->save();
            Log::info('[BookingApplication] Contexto da sessão definido para "booking".');
        }

        // Cria uma instância do BookingFlowManager passando a sessão específica.
        $booking_flow_manager = app()->make(BookingFlowManager::class, ['session' => $session]);

        return $booking_flow_manager->handle($message);
    }
}



================================================
FILE: app/Chat/Applications/ExistingAppointmentApplication.php
================================================
<?php

namespace App\Chat\Applications;

use App\Chat\Contracts\ChatApplicationInterface;
use App\Chat\Enums\BookingState;
use App\Chat\PromptManager;
use App\Models\ChatSession;
use App\Services\SchedulingService;
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;

class ExistingAppointmentApplication implements ChatApplicationInterface
{
    protected SchedulingService $scheduling_service;
    protected PromptManager $prompt_manager;

    public function __construct(
        SchedulingService $scheduling_service,
        PromptManager $prompt_manager
    ) {
        $this->scheduling_service = $scheduling_service;
        $this->prompt_manager = $prompt_manager;
    }

    public function shouldHandle(string $message, ChatSession $session): bool
    {
        if (($session->state['flow'] ?? null) === 'existing_appointment') {
            return true;
        }

        $management_intent = $this->prompt_manager->extractAppointmentManagementIntent($message, $session->id);

        if (in_array($management_intent, ['confirmar', 'cancelar', 'reagendar'])) {
            Log::info('[ExistingAppointmentApplication] Detectou intenção de gerenciamento.', ['intent' => $management_intent]);
            $state = $session->state ?? [];
            $state['pending_management_intent'] = $management_intent;
            $session->state = $state;
            $session->save();
            return true;
        }

        if (empty($session->state) && $session->phone_number) {
            $appointment = $this->scheduling_service->buscarAgendamentoPorTelefone($session->phone_number);
            return !empty($appointment) && ($appointment['sucesso'] ?? false);
        }

        return false;
    }

    public function handle(string $message, ChatSession $session): string
    {
        $state = $session->state ?? [];
        if (($state['flow'] ?? null) !== 'existing_appointment') {
            $state['flow'] = 'existing_appointment';
        }

        if (isset($state['pending_management_intent'])) {
            $intent = $state['pending_management_intent'];
            unset($state['pending_management_intent']);
            $session->state = $state;
            $session->save();

            $appointment = $this->scheduling_service->buscarAgendamentoPorTelefone($session->phone_number);

            if (empty($appointment) || !($appointment['sucesso'] ?? false)) {
                $session->state = null;
                $session->save();
                return "Você tentou {$intent} um agendamento, mas não encontrei nenhum no seu número. Gostaria de marcar um novo?";
            }

            switch ($intent) {
                case 'confirmar':
                    return $this->confirmAppointment($session, $appointment);
                case 'cancelar':
                    return $this->cancelAppointment($session, $appointment);
                case 'reagendar':
                    return $this->rescheduleAppointment($session, $appointment);
            }
        }

        $flow_state = $session->state['flow_state'] ?? 'STARTED';

        if ($flow_state === 'AWAITING_CONFIRMATION') {
            return $this->handleConfirmationAction($message, $session);
        }

        return $this->findAndPresentAppointment($session);
    }

    private function handleConfirmationAction(string $message, ChatSession $session): string
    {
        $appointment_details = $session->state['data']['appointment_details'] ?? null;
        $action = $this->prompt_manager->extractExistingAppointmentAction($message, $session->id);

        Log::info('[ExistingAppointmentApplication] Ação do usuário classificada.', ['action' => $action]);

        switch ($action) {
            case 'confirmar':
                return $this->confirmAppointment($session, $appointment_details);
            case 'cancelar':
                return $this->cancelAppointment($session, $appointment_details);
            case 'reagendar':
                return $this->rescheduleAppointment($session, $appointment_details);
            default:
                return 'Desculpe, não entendi. Você gostaria de *confirmar*, *cancelar* ou *reagendar* o seu agendamento?';
        }
    }

    private function confirmAppointment(ChatSession $session, ?array $appointment_details): string
    {
        if ($appointment_details['confirmado'] ?? false) {
            return "Este agendamento já foi confirmado anteriormente. Se desejar, pode *cancelar* ou *reagendar*.";
        }
        $token = $appointment_details['token_confirmacao'] ?? null;
        if (!$token) return 'Não encontrei as informações para confirmar. Por favor, contacte o suporte.';

        $result = $this->scheduling_service->confirmarAgendamento($token);
        $session->state = null;
        $session->save();
        return $result['resposta']['sucesso']
            ? 'Ótimo! O seu agendamento foi confirmado com sucesso.'
            : 'Houve um problema ao tentar confirmar o seu agendamento. Por favor, tente novamente mais tarde.';
    }

    private function cancelAppointment(ChatSession $session, ?array $appointment_details): string
    {
        $token = $appointment_details['token_cancelamento'] ?? null;
        if (!$token) return 'Não encontrei as informações para cancelar. Por favor, contacte o suporte.';

        $result = $this->scheduling_service->cancelarAgendamento($token);
        $session->state = null;
        $session->save();
        Log::info('[ExistingAppointmentApplication] Agendamento cancelado.', ['result' => $result]);
        return $result['resposta']['sucesso']
            ? 'O seu agendamento foi cancelado. Se precisar de mais alguma coisa, é só chamar.'
            : 'Houve um problema ao tentar cancelar o seu agendamento. Por favor, tente novamente mais tarde.';
    }

    private function rescheduleAppointment(ChatSession $session, ?array $appointment_details): string
    {
        $cancellation_token = $appointment_details['token_cancelamento'] ?? null;

        if ($cancellation_token) {
            $this->scheduling_service->cancelarAgendamento($cancellation_token);
            Log::info('[ExistingAppointmentApplication] Agendamento anterior cancelado para reagendamento.');
        }

        $session->state = [
            'flow' => 'booking',
            'flow_state' => BookingState::INITIAL,
            'data' => [
                'cancellation_token_for_reschedule' => $cancellation_token
            ]
        ];
        $session->save();

        Log::info('[ExistingAppointmentApplication] Iniciando fluxo de reagendamento.', ['cancellation_token' => $cancellation_token]);

        return "Certo, vamos reagendar. Para começarmos, por favor, me informe o estado ou cidade onde deseja o atendimento.";
    }

    private function findAndPresentAppointment(ChatSession $session): string
    {
        $phone_number = $session->phone_number;
        $appointment = $this->scheduling_service->buscarAgendamentoPorTelefone($phone_number);

        if (empty($appointment) || !($appointment['sucesso'] ?? false)) {
            $session->state = null;
            $session->save();
            return app(GreetingApplication::class)->handle('', $session);
        }

        $atendimento_carbon = Carbon::parse($appointment['atendimento_em']);
        $date = $atendimento_carbon->translatedFormat('d \d\e F \d\e Y');
        $time = $atendimento_carbon->format('H:i');

        $response = "Olá! Vi que você tem um agendamento para o dia *{$date} às {$time}h*.";

        if ($appointment['confirmado']) {
            $response .= "\nEste agendamento já está *confirmado*.";
            $response .= "\n\nGostaria de *cancelar* ou *reagendar*?";
        } else {
            $response .= "\nEle *ainda não foi confirmado*.";
            $response .= "\n\nGostaria de *confirmar*, *cancelar* ou *reagendar*?";
        }

        $state = $session->state;
        $state['flow_state'] = 'AWAITING_CONFIRMATION';
        $state['data']['appointment_details'] = $appointment;
        $session->state = $state;
        $session->save();

        return $response;
    }
}



================================================
FILE: app/Chat/Applications/GreetingApplication.php
================================================
<?php

namespace App\Chat\Applications;

use App\Chat\Contracts\ChatApplicationInterface;
use App\Models\ChatSession;
use Illuminate\Support\Facades\Log;

class GreetingApplication implements ChatApplicationInterface
{
    /**
     * O orquestrador determina se esta aplicação deve ser executada.
     */
    public function shouldHandle(string $message, ChatSession $session): bool
    {
        // Esta verificação agora é centralizada e baseada na intenção.
        return false;
    }

    /**
     * Retorna a mensagem de saudação.
     * Esta é uma ação "sem estado" e não deve modificar o estado da sessão.
     */
    public function handle(string $message, ChatSession $session): string
    {
        Log::info('[GreetingApplication] Manipulando a mensagem de saudação.');

        // A aplicação de saudação não define um 'flow', permitindo que a
        // próxima mensagem do usuário seja analisada do zero pelo orquestrador.
        return "Olá! Sou o assistente de agendamento da Pés Sem Dor. Gostaria de agendar uma avaliação?";
    }
}



================================================
FILE: app/Chat/Contracts/ChatApplicationInterface.php
================================================
<?php

namespace App\Chat\Contracts;

use App\Models\ChatSession;

/**
 * Define o contrato para as aplicações de chat que podem manipular
 * diferentes partes de uma conversa.
 */
interface ChatApplicationInterface
{
    /**
     * Determina se esta aplicação deve manipular a mensagem atual do usuário.
     *
     * @param string $message A mensagem enviada pelo usuário.
     * @param ChatSession $session O objeto da sessão de chat, contendo o histórico e o contexto.
     * @return bool Retorna true se a aplicação deve manipular a mensagem, false caso contrário.
     */
    public function shouldHandle(string $message, ChatSession $session): bool;

    /**
     * Processa a mensagem do usuário e retorna a resposta do chatbot.
     *
     * @param string $message A mensagem enviada pelo usuário.
     * @param ChatSession $session O objeto da sessão de chat.
     * @return string A resposta do bot para ser enviada ao usuário.
     */
    public function handle(string $message, ChatSession $session): string;
}



================================================
FILE: app/Chat/Enums/BookingState.php
================================================
<?php

namespace App\Chat\Enums;

final class BookingState
{
    public const INITIAL = 'initial';
    public const AWAITING_LOCATION = 'awaiting_location';
    public const AWAITING_LOCATION_CHOICE = 'awaiting_location_choice';
    public const AWAITING_DATE_TIME = 'awaiting_date_time';
    public const AWAITING_NAME = 'awaiting_name';
    public const AWAITING_PHONE = 'awaiting_phone';
    public const AWAITING_CONFIRMATION = 'awaiting_confirmation';
    public const AWAITING_CORRECTION = 'awaiting_correction';
    public const COMPLETED = 'completed';
}



================================================
FILE: app/Chat/Flows/BookingFlowManager.php
================================================
<?php

namespace App\Chat\Flows;

use App\Chat\ConversationAnalyzerService;
use App\Chat\Enums\BookingState;
use App\Chat\Flows\BookingFlow\StateHandlerFactory;
use App\Models\ChatSession;

/**
 * Class BookingFlowManager (Refatorado)
 * Orquestra o fluxo de agendamento, delegando a lógica para manipuladores de estado específicos.
 */
class BookingFlowManager
{
    protected StateHandlerFactory $state_handler_factory;
    protected ChatSession $session;

    public function __construct(StateHandlerFactory $state_handler_factory, ChatSession $session)
    {
        $this->state_handler_factory = $state_handler_factory;
        $this->session = $session;
    }

    /**
     * Ponto de entrada para manipular a mensagem do usuário dentro do fluxo de agendamento.
     */
    public function handle(string $message): string
    {
        // Obtém o estado atual da sessão, ou define como INITIAL se não existir.
        $current_state = $this->session->state['flow_state'] ?? BookingState::INITIAL;

        // Analisa a mensagem para extrair intenção, localização, etc.
        $analyzer = app(ConversationAnalyzerService::class);
        $analysis = $analyzer->analyze($message, $this->session);

        // Usa a fábrica para obter o manipulador de estado correto.
        $handler = $this->state_handler_factory->make($current_state);

        // Delega o processamento da mensagem para o manipulador de estado.
        return $handler->handle($message, $this->session, $analysis);
    }
}



================================================
FILE: app/Chat/Flows/BookingFlow/StateHandlerFactory.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow;

use App\Chat\Enums\BookingState;
use App\Chat\Flows\BookingFlow\Contracts\StateHandler;
use App\Chat\Flows\BookingFlow\States\AwaitingConfirmationState;
use App\Chat\Flows\BookingFlow\States\AwaitingCorrectionState;
use App\Chat\Flows\BookingFlow\States\AwaitingDateTimeState;
use App\Chat\Flows\BookingFlow\States\AwaitingLocationChoiceState;
use App\Chat\Flows\BookingFlow\States\AwaitingLocationState;
use App\Chat\Flows\BookingFlow\States\AwaitingNameState;
use App\Chat\Flows\BookingFlow\States\AwaitingPhoneState;
use App\Chat\Flows\BookingFlow\States\InitialState;
use Illuminate\Contracts\Container\Container;
use InvalidArgumentException;

/**
 * Class StateHandlerFactory
 * Responsável por criar a instância correta do manipulador de estado com base no estado atual.
 */
class StateHandlerFactory
{
    protected Container $container;

    protected array $state_map = [
        BookingState::INITIAL => InitialState::class,
        BookingState::AWAITING_LOCATION => AwaitingLocationState::class,
        BookingState::AWAITING_LOCATION_CHOICE => AwaitingLocationChoiceState::class,
        BookingState::AWAITING_DATE_TIME => AwaitingDateTimeState::class,
        BookingState::AWAITING_NAME => AwaitingNameState::class,
        BookingState::AWAITING_PHONE => AwaitingPhoneState::class,
        BookingState::AWAITING_CONFIRMATION => AwaitingConfirmationState::class,
        BookingState::AWAITING_CORRECTION => AwaitingCorrectionState::class,
    ];

    public function __construct(Container $container)
    {
        $this->container = $container;
    }

    /**
     * Cria e retorna a instância do manipulador para o estado fornecido.
     *
     * @param string $state O estado atual do fluxo.
     * @return StateHandler
     */
    public function make(string $state): StateHandler
    {
        if (!isset($this->state_map[$state])) {
            throw new InvalidArgumentException("Nenhum manipulador de estado encontrado para o estado: {$state}");
        }

        $class = $this->state_map[$state];
        return $this->container->make($class);
    }
}



================================================
FILE: app/Chat/Flows/BookingFlow/Contracts/StateHandler.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow\Contracts;

use App\Models\ChatSession;
use App\Data\ConversationAnalysisDTO;

/**
 * Interface StateHandler
 * Define o contrato para todas as classes que representam um estado no fluxo de agendamento.
 */
interface StateHandler
{
    /**
     * Manipula a mensagem do usuário para o estado atual.
     *
     * @param string $message A mensagem do usuário.
     * @param ChatSession $session A sessão de chat atual.
     * @param ConversationAnalysisDTO|null $analysis A análise da conversa.
     * @return string A resposta do chatbot.
     */
    public function handle(string $message, ChatSession $session, ?ConversationAnalysisDTO $analysis): string;
}



================================================
FILE: app/Chat/Flows/BookingFlow/States/AbstractStateHandler.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow\States;

use App\Chat\Enums\BookingState;
use App\Models\ChatSession;
use Carbon\Carbon;

/**
 * Class AbstractStateHandler
 * Contém a lógica compartilhada entre os diferentes manipuladores de estado.
 */
abstract class AbstractStateHandler
{
    /**
     * Atualiza o estado do fluxo na sessão.
     */
    protected function updateState(ChatSession $session, string $new_state): void
    {
        $state = $session->state ?? [];
        $state['flow_state'] = $new_state;
        $session->state = $state;
        $session->save();
    }

    /**
     * Atualiza os dados armazenados na sessão.
     */
    protected function updateData(ChatSession $session, array $data): void
    {
        $state = $session->state ?? [];
        $state['data'] = array_merge($state['data'] ?? [], $data);
        $session->state = $state;
        $session->save();
    }

    /**
     * Limpa o estado da conversa na sessão.
     */
    protected function clearConversationState(ChatSession $session): void
    {
        $session->state = null;
        $session->save();
    }

    /**
     * Formata a lista de unidades para exibição ao usuário.
     */
    protected function formatUnitList(ChatSession $session, array $units, string $context): string
    {
        if (empty($units)) {
            return "Não encontrei unidades disponíveis {$context}.";
        }

        $this->updateData($session, ['unidades_filtradas' => array_values($units)]);
        $this->updateState($session, BookingState::AWAITING_LOCATION_CHOICE);

        $response_text = "Encontrei estas unidades {$context}:\n\n";
        foreach (array_values($units) as $index => $unit) {
            $response_text .= ($index + 1) . ". *{$unit['nomeFranquia']}* - {$unit['bairroFranquia']}, {$unit['cidadeFranquia']}\n";
        }
        $response_text .= "\nQual destas unidades você prefere? Você também pode informar um bairro para refinar a busca.";
        return $response_text;
    }

    /**
     * Formata a lista de horários disponíveis.
     */
    protected function formatAvailableSlots(array $slots, string $unit_name): string
    {
        $response_text = "Para a unidade *{$unit_name}*, encontrei os seguintes horários:\n\n";
        $found_slots = false;
        foreach ($slots as $date => $times) {
            if (!empty($times)) {
                $found_slots = true;
                $formatted_date = Carbon::parse($date)->translatedFormat('l, d \d\e F');
                $response_text .= "*{$formatted_date}:*\n" . implode(' - ', array_map(fn($t) => substr($t, 0, 5), array_keys($times))) . "\n\n";
            }
        }
        return $found_slots ? $response_text . "Qual dia e horário você prefere?" : "Não encontrei horários disponíveis para *{$unit_name}*.";
    }

    /**
     * Gera o texto de confirmação do agendamento.
     */
    protected function getConfirmationText(ChatSession $session): string
    {
        $data = $session->state['data'];
        $date = Carbon::parse($data['chosen_date'])->translatedFormat('d/m/Y');
        return "Vamos confirmar os dados?\n\n*Unidade:* {$data['chosen_unit']['nomeFranquia']}\n*Data:* {$date}\n*Horário:* {$data['chosen_time']}\n*Nome:* {$data['user_name']}\n*Telefone:* {$data['full_phone']}\n\nEstá tudo correto? (Sim/Não)";
    }
}



================================================
FILE: app/Chat/Flows/BookingFlow/States/AwaitingConfirmationState.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow\States;

use App\Chat\Enums\BookingState;
use App\Chat\Flows\BookingFlow\Contracts\StateHandler;
use App\Data\ConversationAnalysisDTO;
use App\Models\ChatSession;
use App\Services\SchedulingService;
use Illuminate\Support\Facades\Log;

class AwaitingConfirmationState extends AbstractStateHandler implements StateHandler
{
    protected SchedulingService $scheduling_service;

    public function __construct(SchedulingService $scheduling_service)
    {
        $this->scheduling_service = $scheduling_service;
    }

    public function handle(string $message, ChatSession $session, ?ConversationAnalysisDTO $analysis): string
    {
        Log::info('[AwaitingConfirmationState] Analisando resposta de confirmação.', ['intent' => $analysis->intent]);

        if ($analysis?->intent === 'afirmativa') {
            $data = $session->state['data'];

            $payload = [
                'name' => $data['user_name'],
                'ddd' => $data['user_ddd'],
                'phone' => $data['user_phone'],
                'date' => $data['chosen_date'],
                'time' => $data['chosen_time'],
                'unit_franchise_group' => $data['chosen_unit']['grupoFranquia'],
                // Adiciona o token de cancelamento se estiver presente na sessão (fluxo de reagendamento)
                'cancellation_token' => $data['cancellation_token_for_reschedule'] ?? null,
            ];

            $result = $this->scheduling_service->criarAgendamento($payload);
            $this->clearConversationState($session);

            $success_message = "Perfeito! Seu agendamento foi confirmado.";
            if (!empty($payload['cancellation_token'])) {
                $success_message = "Perfeito! Seu novo agendamento foi confirmado e o anterior cancelado.";
            }

            return ($result['result'] ?? 0) === 1 ? $success_message : ($result['success'] ?? "Houve um problema ao agendar.");
        }

        if ($analysis?->intent === 'negativa') {
            $this->updateState($session, BookingState::AWAITING_CORRECTION);
            return "Entendido. O que você gostaria de corrigir? (Unidade, data/hora, nome ou telefone)";
        }

        return "Por favor, responda com 'Sim' para confirmar ou 'Não' para corrigir alguma informação.";
    }
}



================================================
FILE: app/Chat/Flows/BookingFlow/States/AwaitingCorrectionState.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow\States;

use App\Chat\Enums\BookingState;
use App\Chat\Flows\BookingFlow\Contracts\StateHandler;
use App\Chat\PromptManager;
use App\Data\ConversationAnalysisDTO;
use App\Models\ChatSession;
use App\Services\SchedulingService;
use Illuminate\Support\Facades\Log;

class AwaitingCorrectionState extends AbstractStateHandler implements StateHandler
{
    protected PromptManager $prompt_manager;
    protected SchedulingService $scheduling_service;

    public function __construct(PromptManager $prompt_manager, SchedulingService $scheduling_service)
    {
        $this->prompt_manager = $prompt_manager;
        $this->scheduling_service = $scheduling_service;
    }

    public function handle(string $message, ChatSession $session, ?ConversationAnalysisDTO $analysis): string
    {
        $correction_field = $this->prompt_manager->extractCorrectionField($message, $session->id);
        Log::info('[AwaitingCorrectionState] IA identificou campo para correção.', ['campo' => $correction_field]);
        $data = $session->state['data'];

        switch ($correction_field) {
            case 'unidade':
                unset($data['chosen_unit'], $data['unidades_filtradas'], $data['criterios_atuais']);
                $this->updateData($session, $data);
                $this->updateState($session, BookingState::AWAITING_LOCATION);
                return "Ok, vamos corrigir a unidade. Por favor, informe novamente a cidade ou estado.";

            case 'data':
                unset($data['chosen_date'], $data['chosen_time']);
                $this->updateData($session, $data);
                $this->updateState($session, BookingState::AWAITING_DATE_TIME);
                $horarios = $this->scheduling_service->obterHorariosDisponiveisPorPeriodo($data['chosen_unit']['grupoFranquia']);
                return "Certo, vamos alterar a data e hora. " . $this->formatAvailableSlots($horarios, $data['chosen_unit']['nomeFranquia']);

            case 'nome':
                unset($data['user_name']);
                $this->updateData($session, $data);
                $this->updateState($session, BookingState::AWAITING_NAME);
                return "Entendido. Por favor, informe o seu nome completo correto.";

            case 'telefone':
                unset($data['user_phone'], $data['user_ddd'], $data['full_phone']);
                $this->updateData($session, $data);
                $this->updateState($session, BookingState::AWAITING_PHONE);
                return "Ok. Por favor, informe o número de telefone correto, com DDD.";

            default:
                return "Não entendi o que precisa ser corrigido. Por favor, diga se o erro está na 'unidade', 'data', 'nome' ou 'telefone'.";
        }
    }
}



================================================
FILE: app/Chat/Flows/BookingFlow/States/AwaitingDateTimeState.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow\States;

use App\Chat\Enums\BookingState;
use App\Chat\Flows\BookingFlow\Contracts\StateHandler;
use App\Chat\PromptManager;
use App\Data\ConversationAnalysisDTO;
use App\Models\ChatSession;

class AwaitingDateTimeState extends AbstractStateHandler implements StateHandler
{
    protected PromptManager $prompt_manager;

    public function __construct(PromptManager $prompt_manager)
    {
        $this->prompt_manager = $prompt_manager;
    }

    public function handle(string $message, ChatSession $session, ?ConversationAnalysisDTO $analysis): string
    {
        $date_time_data = $this->prompt_manager->extractDateTime($message, $session->id);

        if ($date_time_data === null) {
            return "Não consegui entender o dia e o horário. Por favor, tente informar novamente (ex: 'amanhã às 15h').";
        }

        $this->updateData($session, ['chosen_date' => $date_time_data['date'], 'chosen_time' => $date_time_data['time']]);
        $this->updateState($session, BookingState::AWAITING_NAME);
        return "Entendido. Para continuar, por favor, me informe seu nome completo.";
    }
}



================================================
FILE: app/Chat/Flows/BookingFlow/States/AwaitingLocationChoiceState.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow\States;

use App\Chat\Enums\BookingState;
use App\Chat\Flows\BookingFlow\Contracts\StateHandler;
use App\Chat\PromptManager;
use App\Data\ConversationAnalysisDTO;
use App\Models\ChatSession;
use App\Services\SchedulingService;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

class AwaitingLocationChoiceState extends AbstractStateHandler implements StateHandler
{
    protected PromptManager $prompt_manager;
    protected SchedulingService $scheduling_service;

    public function __construct(PromptManager $prompt_manager, SchedulingService $scheduling_service)
    {
        $this->prompt_manager = $prompt_manager;
        $this->scheduling_service = $scheduling_service;
    }

    public function handle(string $message, ChatSession $session, ?ConversationAnalysisDTO $analysis): string
    {
        $current_units = $session->state['data']['unidades_filtradas'] ?? [];
        Log::info('[AwaitingLocationChoiceState] Iniciando handle.', [
            'session_id' => $session->id,
            'message' => $message,
            'unidades_em_contexto' => count($current_units)
        ]);

        // Lógica para escolha por número (mais rápido e direto)
        if (is_numeric(trim($message))) {
            $index = intval(trim($message)) - 1;
            if (isset($current_units[$index])) {
                Log::info('[AwaitingLocationChoiceState] Usuário escolheu por número.', ['index' => $index, 'unidade' => $current_units[$index]['nomeFranquia']]);
                return $this->proceedToDateTime($session, $current_units[$index]);
            }
        }

        // Nova lógica: Usa o extrator de entidades para entender a escolha
        $entities = $this->prompt_manager->extractEntities($message, $session->id, $session->getFormattedHistory());
        Log::info('[AwaitingLocationChoiceState] Entidades extraídas da mensagem.', ['entities' => $entities?->toArray()]);

        $chosen_unit_name = $entities->unit_name ?? $entities->location_value; // Pode ser nome da unidade ou um bairro para refinar

        if ($chosen_unit_name) {
            $normalized_choice = Str::ascii(Str::lower($chosen_unit_name));
            Log::info('[AwaitingLocationChoiceState] Tentando encontrar unidade por nome/localização.', ['escolha_normalizada' => $normalized_choice]);

            // Tenta encontrar a unidade exata pelo nome
            foreach ($current_units as $unit) {
                $franchise_name = $unit['nomeFranquia'];
                $normalized_franchise_name = Str::ascii(Str::lower($franchise_name));
                if (Str::contains($normalized_franchise_name, $normalized_choice)) {
                    Log::info('[AwaitingLocationChoiceState] Unidade correspondente encontrada.', ['unidade' => $franchise_name]);
                    return $this->proceedToDateTime($session, $unit);
                }
            }

            Log::info('[AwaitingLocationChoiceState] Nenhuma unidade exata encontrada. Verificando se é um refinamento de busca.');
            // CORREÇÃO: Se não encontrou uma unidade, verifica se o usuário
            // tentou refinar a busca com um bairro ou cidade.
            if ($entities->location_type === 'neighborhood' || $entities->location_type === 'city') {
                // Filtra a lista atual de unidades com o novo critério.
                $bairro_filtro = $entities->location_type === 'neighborhood' ? $chosen_unit_name : null;
                $cidade_filtro = $entities->location_type === 'city' ? $chosen_unit_name : null;

                Log::info('[AwaitingLocationChoiceState] Refinando busca com novos critérios.', ['bairro' => $bairro_filtro, 'cidade' => $cidade_filtro]);
                $refined_units = $this->scheduling_service->filtrarUnidades($current_units, bairro: $bairro_filtro, cidade: $cidade_filtro);
                Log::info('[AwaitingLocationChoiceState] Resultado do refinamento.', ['unidades_encontradas' => count($refined_units)]);

                if (!empty($refined_units)) {
                    // Apresenta a nova lista refinada para o usuário.
                    return $this->formatUnitList($session, $refined_units, "em {$chosen_unit_name}");
                }
            }
        }

        Log::warning('[AwaitingLocationChoiceState] Não foi possível interpretar a escolha do usuário.', ['message' => $message]);
        return "Não consegui entender. Por favor, digite o **número** da unidade que você deseja ou um **bairro** para refinar a busca.";
    }

    private function proceedToDateTime(ChatSession $session, array $chosen_unit): string
    {
        $this->updateData($session, ['chosen_unit' => $chosen_unit]);
        $this->updateState($session, BookingState::AWAITING_DATE_TIME);
        $available_slots = $this->scheduling_service->obterHorariosDisponiveisPorPeriodo($chosen_unit['grupoFranquia']);

        if (empty($available_slots)) {
            Log::warning('[AwaitingLocationChoiceState] Unidade escolhida não possui horários.', ['unidade' => $chosen_unit['nomeFranquia']]);
            $this->updateState($session, BookingState::AWAITING_LOCATION_CHOICE);
            $this->updateData($session, ['chosen_unit' => null]);
            return "A unidade *{$chosen_unit['nomeFranquia']}* não tem horários disponíveis. Gostaria de escolher outra?";
        }

        return $this->formatAvailableSlots($available_slots, $chosen_unit['nomeFranquia']);
    }
}



================================================
FILE: app/Chat/Flows/BookingFlow/States/AwaitingLocationState.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow\States;

use App\Chat\Flows\BookingFlow\Contracts\StateHandler;
use App\Data\ConversationAnalysisDTO;
use App\Models\ChatSession;
use App\Services\SchedulingService;
use App\Services\GoogleMapsService;
use App\Chat\PromptManager;
use Illuminate\Support\Facades\Log;

class AwaitingLocationState extends AbstractStateHandler implements StateHandler
{
    protected SchedulingService $scheduling_service;
    protected GoogleMapsService $google_maps_service;
    protected PromptManager $prompt_manager;

    public function __construct(
        SchedulingService $scheduling_service,
        GoogleMapsService $google_maps_service,
        PromptManager $prompt_manager
    ) {
        $this->scheduling_service = $scheduling_service;
        $this->google_maps_service = $google_maps_service;
        $this->prompt_manager = $prompt_manager;
    }

    public function handle(string $message, ChatSession $session, ?ConversationAnalysisDTO $analysis): string
    {
        $entities = $this->prompt_manager->extractEntities($message, $session->id, $session->getFormattedHistory());

        if (!$entities || !$entities->location_type || !$entities->location_value) {
            return "Não consegui entender a localização. Por favor, envie o nome de um estado, cidade ou CEP.";
        }

        return $this->processLocationSearch($session, $entities->location_type, $entities->location_value);
    }

    private function processLocationSearch(ChatSession $session, string $location_type, string $location_value): string
    {
        Log::info('[AwaitingLocationState] Iniciando busca de localização.', ['type' => $location_type, 'value' => $location_value]);
        $context = '';

        if ($location_type === 'cep') {
            $coordinates = $this->google_maps_service->getCoordinatesFromCep($location_value);
            if (!$coordinates) {
                return "Não consegui encontrar a localização para o CEP informado. Por favor, tente novamente ou informe uma cidade.";
            }

            $nearest_unit = $this->scheduling_service->obterUnidadeMaisProxima($coordinates['latitude'], $coordinates['longitude']);

            if (!$nearest_unit) {
                return "Infelizmente, não encontrei unidades próximas a este CEP. Gostaria de tentar buscar por cidade e estado?";
            }

            $context = "mais próxima do CEP {$location_value}";
            return $this->formatUnitList($session, [$nearest_unit], $context);
        }

        $all_units = $this->scheduling_service->obterTodasAsUnidadesAtivas();
        $filtered_units = [];

        if ($location_type === 'state') {
            $filtered_units = $this->scheduling_service->filtrarUnidades($all_units, estado: $location_value);
            $context = "no estado de {$location_value}";
            $this->updateData($session, ['criterios_atuais' => ['estado' => $location_value]]);
        } else { // city or neighborhood
            $filtered_units = $this->scheduling_service->filtrarUnidades($all_units, cidade: $location_value);
            $context = "na cidade de {$location_value}";
            $this->updateData($session, ['criterios_atuais' => ['cidade' => $location_value]]);
        }

        Log::info('[AwaitingLocationState] Unidades filtradas.', ['count' => count($filtered_units), 'contexto' => $context]);
        return $this->formatUnitList($session, $filtered_units, $context);
    }
}



================================================
FILE: app/Chat/Flows/BookingFlow/States/AwaitingNameState.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow\States;

use App\Chat\Enums\BookingState;
use App\Chat\Flows\BookingFlow\Contracts\StateHandler;
use App\Data\ConversationAnalysisDTO;
use App\Models\ChatSession;

class AwaitingNameState extends AbstractStateHandler implements StateHandler
{
    public function handle(string $message, ChatSession $session, ?ConversationAnalysisDTO $analysis): string
    {
        $this->updateData($session, ['user_name' => $message]);
        $this->updateState($session, BookingState::AWAITING_PHONE);
        return "Obrigado, {$message}. Agora, por favor, me informe seu telefone com DDD.";
    }
}



================================================
FILE: app/Chat/Flows/BookingFlow/States/AwaitingPhoneState.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow\States;

use App\Chat\Enums\BookingState;
use App\Chat\Flows\BookingFlow\Contracts\StateHandler;
use App\Data\ConversationAnalysisDTO;
use App\Models\ChatSession;

class AwaitingPhoneState extends AbstractStateHandler implements StateHandler
{
    public function handle(string $message, ChatSession $session, ?ConversationAnalysisDTO $analysis): string
    {
        $cleaned_phone = preg_replace('/\D/', '', $message);
        if (strlen($cleaned_phone) < 10 || strlen($cleaned_phone) > 11) {
            return "O número de telefone parece inválido. Por favor, envie novamente com o DDD.";
        }
        $this->updateData($session, [
            'user_ddd' => substr($cleaned_phone, 0, 2),
            'user_phone' => substr($cleaned_phone, 2),
            'full_phone' => $cleaned_phone
        ]);
        $this->updateState($session, BookingState::AWAITING_CONFIRMATION);
        return $this->getConfirmationText($session);
    }
}



================================================
FILE: app/Chat/Flows/BookingFlow/States/InitialState.php
================================================
<?php

namespace App\Chat\Flows\BookingFlow\States;

use App\Chat\Enums\BookingState;
use App\Chat\Flows\BookingFlow\Contracts\StateHandler;
use App\Data\ConversationAnalysisDTO;
use App\Models\ChatSession;
use App\Services\SchedulingService;
use App\Chat\PromptManager;
use Illuminate\Support\Facades\Log;

class InitialState extends AbstractStateHandler implements StateHandler
{
    protected SchedulingService $scheduling_service;
    protected PromptManager $prompt_manager;

    public function __construct(SchedulingService $scheduling_service, PromptManager $prompt_manager)
    {
        $this->scheduling_service = $scheduling_service;
        $this->prompt_manager = $prompt_manager;
    }

    public function handle(string $message, ChatSession $session, ?ConversationAnalysisDTO $analysis): string
    {
        // No estado inicial, verificamos se a primeira mensagem já contém uma localização.
        $entities = $this->prompt_manager->extractEntities($message, $session->id, $session->getFormattedHistory());

        if ($entities && $entities->location_type && $entities->location_value) {
            // Se sim, já podemos pular para o estado AWAITING_LOCATION para processar.
            $this->updateState($session, BookingState::AWAITING_LOCATION);
            $awaitingLocationState = app(AwaitingLocationState::class);
            return $awaitingLocationState->handle($message, $session, $analysis);
        }

        // Se não, mudamos o estado para aguardar a localização e pedimos ao usuário.
        $this->updateState($session, BookingState::AWAITING_LOCATION);
        return "Para começarmos, por favor, me informe o estado, a cidade ou o CEP onde deseja o atendimento.";
    }
}



================================================
FILE: app/Chat/Prompts/AttendantPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class AttendantPrompt
{
    /**
     * Constrói o prompt de sistema que define a persona e o conhecimento do atendente.
     *
     * @param array $data Dados dinâmicos para preencher o prompt (ex: nome do cliente).
     * @return string O prompt de sistema formatado.
     */
    public function build(array $data = []): string
    {
        $nome_cliente = $data['nome_cliente'] ?? 'o cliente';
        $data_cliente = $data['data_cliente'] ?? 'uma data anterior';
        $horario_cliente = $data['horario_cliente'] ?? 'um horário anterior';
        $unidade_cliente = $data['unidade_cliente'] ?? 'uma de nossas unidades';
        $endereco_cliente = $data['endereco_cliente'] ?? 'o endereço da unidade';

        return <<<PROMPT
## Contexto ##
Você é o atendente virtual responsável pelos agendamentos via WhatsApp na empresa Pés Sem Dor, especializada em palmilhas e calçados sob medida, com mais de 90 unidades espalhadas por todo o Brasil.

Seu objetivo é reagendar a avaliação anteriormente marcada para o dia {$data_cliente} às {$horario_cliente} na unidade {$unidade_cliente} localizada no endereço {$endereco_cliente}, na qual o cliente {$nome_cliente} não compareceu.

A avaliação é gratuita, realizada presencialmente por especialistas em saúde dos pés, tornozelos e joelhos, todos graduados em fisioterapia. O compromisso é resolver as dores dos clientes em até 90 dias, ou devolver todo o dinheiro gasto com os produtos como forma de garantia. Os produtos incluem diversos modelos de palmilhas e calçados sob medida, feitos com tecnologia de ponta para eliminar as dores do cliente de forma personalizada.
Informações sobre o preço dos produtos serão disponibilizadas somente após avaliação com o especialista. nunca informe ao cliente o preço dos produtos ou ofereça reembolso de algum valor.
Não fornecemos atestados de horário, apenas uma declaração de comparecimento assinada pela recepção da unidade.
Não temos convênio com estacionamento.

O atendimento é estritamente profissional; portanto, evite o uso de emojis carinhosos ou expressões amorosas ao se comunicar com os clientes. Nunca peça para o cliente aguardar, pois você é um atendente virtual com respostas imediatas.
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/ConfirmationAttendantPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class ConfirmationAttendantPrompt
{
    /**
     * Constrói o prompt de persona para o atendente de confirmação.
     * Este prompt define o contexto e as regras para a IA.
     *
     * @return string O prompt de sistema.
     */
    public function build(): string
    {
        return <<<PROMPT
## Contexto ##
Você é o atendente virtual responsável pelos agendamentos via WhatsApp na empresa Pés Sem Dor, especializada em palmilhas e calçados sob medida, com mais de 90 unidades espalhadas por todo o Brasil.

Seu objetivo é confirmar a presença de um cliente em sua avaliação agendada, ou reagendá-la caso o cliente não possa comparecer.

A avaliação é gratuita, realizada presencialmente por especialistas em saúde dos pés, tornozelos e joelhos, todos graduados em fisioterapia. O compromisso é resolver as dores dos clientes em até 90 dias, ou devolver todo o dinheiro gasto com os produtos como forma de garantia.

## Regras de Negócio ##
- Informações sobre o preço dos produtos serão disponibilizadas somente após avaliação com o especialista. Nunca informe ao cliente o preço dos produtos.
- Não fornecemos atestado de horário, apenas uma declaração de comparecimento.
- Não fornecemos laudo com as imagens coletadas na avaliação.
- Não temos convênio com estacionamento.
- É necessário trazer um documento de identificação pessoal (RG, CNH, etc).

## Regras de Comportamento ##
- O atendimento é estritamente profissional; evite o uso de emojis carinhosos ou expressões amorosas.
- Sua principal tarefa é obter uma resposta do cliente para saber se ele irá comparecer, se deseja reagendar ou cancelar.
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/EntityExtractorPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class EntityExtractorPrompt
{
    /**
     * Constrói o prompt para extrair entidades da mensagem do usuário.
     *
     * @param string $user_message A mensagem do usuário.
     * @return string O prompt formatado.
     */
    public function build(string $user_message): string
    {
        $today = now()->format('d/m/Y');

        return <<<PROMPT
## Contexto ##
Você é um especialista em extração de informações (entidades) de texto. A data de hoje é {$today}.

## Tarefa ##
1. Analise a MENSAGEM DO CLIENTE e extraia as seguintes entidades: NOME, TELEFONE, DATA e HORA.
2. Se uma entidade não for encontrada, retorne `null` para seu valor.

## Regras ##
1. Normalize as informações:
   - TELEFONE: Apenas números.
   - DATA: Formato AAAA-MM-DD.
   - HORA: Formato HH:MM (24h).
2. A resposta deve ser APENAS um objeto JSON.

## Saída ##
{"NOME": "string|null", "TELEFONE": "string|null", "DATA": "string|null", "HORA": "string|null"}

MENSAGEM DO CLIENTE: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/ExistingAppointmentActionPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

/**
 * Constrói o prompt para a IA classificar a ação do utilizador sobre um agendamento existente.
 */
class ExistingAppointmentActionPrompt
{
    public function build(string $user_message): string
    {
        return <<<PROMPT
Você é um assistente especialista em agendamentos de Pés Sem Dor no Brasil, fluente em português brasileiro.

Pense passo a passo: 1. Identifique palavras-chave na mensagem. 2. Compare com ações possíveis: confirmar, cancelar ou reagendar. 3. Avalie a confiança na classificação (0.0 a 1.0).

A intenção dele é 'confirmar', 'cancelar' ou 'reagendar'?
Responda APENAS com um objeto JSON: {"action": "confirmar/cancelar/reagendar", "confidence": número}.

Exemplos:
- Mensagem: "quero confirmar" -> {"action": "confirmar", "confidence": 1.0}
- Mensagem: "sim, confirmo" -> {"action": "confirmar", "confidence": 1.0}
- Mensagem: "pode cancelar" -> {"action": "cancelar", "confidence": 1.0}
- Mensagem: "não quero mais" -> {"action": "cancelar", "confidence": 0.9}
- Mensagem: "gostaria de mudar a data" -> {"action": "reagendar", "confidence": 1.0}
- Mensagem: "troca pra outro dia" -> {"action": "reagendar", "confidence": 0.95}
- Mensagem: "tudo bem, vai nessa" -> {"action": "confirmar", "confidence": 0.8}
- Mensagem: "desisto, cancela aí" -> {"action": "cancelar", "confidence": 0.9}

Mensagem do usuário: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/ExistingAppointmentIntentPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class ExistingAppointmentIntentPrompt
{
    public function build(string $user_message): string
    {
        return <<<PROMPT
Analise a mensagem do usuário, que já sabe que tem um agendamento.
A intenção dele é 'confirmar', 'cancelar' ou 'reagendar'?
Responda APENAS com uma dessas três palavras.

Mensagem: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/ExtractAppointmentManagementIntentPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

/**
 * Constrói o prompt para a IA identificar se a intenção do usuário é gerenciar um agendamento.
 */
class ExtractAppointmentManagementIntentPrompt
{
    public function build(string $user_message): string
    {
        return <<<PROMPT
Analise a mensagem do usuário para identificar se a intenção principal é 'confirmar', 'cancelar' ou 'reagendar' um agendamento.
Se a intenção não for clara ou não estiver relacionada a uma dessas três ações, responda 'nenhuma'.
Responda APENAS com uma das quatro palavras: 'confirmar', 'cancelar', 'reagendar', ou 'nenhuma'.

Exemplos:
- Mensagem: "eu preciso cancelar minha consulta" -> cancelar
- Mensagem: "quero confirmar meu horário" -> confirmar
- Mensagem: "preciso mudar o dia" -> reagendar
- Mensagem: "quero agendar uma avaliação" -> nenhuma
- Mensagem: "oi, tudo bem?" -> nenhuma

Mensagem do usuário: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/ExtractCorrectionPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

/**
 * Constrói o prompt para a IA identificar qual parte do agendamento o usuário deseja corrigir.
 */
class ExtractCorrectionPrompt
{
    public function build(string $user_message): string
    {
        return <<<PROMPT
Analise a mensagem do usuário, que está a indicar qual parte de um resumo de agendamento está incorreta.
As opções possíveis são: 'unidade', 'data', 'nome', 'telefone'.

Identifique qual dessas quatro opções o usuário quer corrigir.
Responda APENAS com uma única palavra: 'unidade', 'data', 'nome', ou 'telefone'.
Se não tiver certeza, responda 'desconhecido'.

Exemplos:
- Mensagem: "a data está errada" -> data
- Mensagem: "na verdade é em outra unidade" -> unidade
- Mensagem: "meu nome não é esse" -> nome
- Mensagem: "o telefone que passei está incorreto" -> telefone
- Mensagem: "o horário" -> data

Mensagem do usuário: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/ExtractDateTimePrompt.php
================================================
<?php

namespace App\Chat\Prompts;

use Carbon\Carbon;

class ExtractDateTimePrompt
{
    public function build(string $user_message): string
    {
        $today = now()->format('Y-m-d');
        $tomorrow = now()->addDay()->format('Y-m-d');
        $next_friday = now()->next(Carbon::FRIDAY)->format('Y-m-d');
        $next_week = now()->addWeek()->format('Y-m-d');

        return <<<PROMPT
Você é um assistente especialista em agendamentos da Pés Sem Dor no Brasil, fluente em português brasileiro.

Pense passo a passo: 1. Converta expressões relativas (ex: 'fim de tarde' para '18:00'). 2. Calcule datas dinâmicas. 3. Avalie confiança.

A data de hoje é {$today}. Extraia data e hora.

Responda APENAS com JSON: {"date": "YYYY-MM-DD"/null, "time": "HH:MM"/null, "confidence": número}.

Exemplos:
- Mensagem: "pode ser amanhã às 10h" -> {"date": "{$tomorrow}", "time": "10:00", "confidence": 1.0}
- Mensagem: "dia 29 às 15" -> {"date": "2025-08-29", "time": "15:00", "confidence": 0.9}
- Mensagem: "sexta-feira 9 da manhã" -> {"date": "{$next_friday}", "time": "09:00", "confidence": 1.0}
- Mensagem: "16:00" -> {"date": null, "time": "16:00", "confidence": 1.0}
- Mensagem: "hoje às duas e meia da tarde" -> {"date": "{$today}", "time": "14:30", "confidence": 1.0}
- Mensagem: "quero para depois de amanhã" -> {"date": "{$tomorrow}", "time": null, "confidence": 0.95}
- Mensagem: "próxima semana ao meio-dia" -> {"date": "{$next_week}", "time": "12:00", "confidence": 0.85}
- Mensagem: "fim de tarde na quinta" -> {"date": data da próxima quinta, "time": "18:00", "confidence": 0.8}

Mensagem do usuário: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/ExtractFilterCriteriaPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

/**
 * Constrói o prompt para a IA extrair critérios de filtro da mensagem do utilizador.
 */
class ExtractFilterCriteriaPrompt
{
    public function build(string $userMessage): string
    {
        return <<<PROMPT
Você é um assistente especialista em agendamentos d Pés Sem Dor no Brasil, fluente em português brasileiro.

Pense passo a passo: 1. Identifique critérios como cidade, bairro ou zona. 2. Normalize (ex: "capital" para "são paulo"). 3. Avalie confiança.

Extraia critérios de filtro. Responda APENAS com JSON: {"cidade": string/null, "bairro": string/null, "zona": string/null, "confidence": número}.

Exemplos:
- Mensagem: "quais as opções na capital?" -> {"cidade": "são paulo", "bairro": null, "zona": null, "confidence": 1.0}
- Mensagem: "tem alguma no bairro de moema?" -> {"cidade": null, "bairro": "moema", "zona": null, "confidence": 1.0}
- Mensagem: "unidades da zona leste" -> {"cidade": null, "bairro": null, "zona": "zona leste", "confidence": 1.0}
- Mensagem: "quero ver todas" -> {"cidade": null, "bairro": null, "zona": null, "confidence": 1.0}
- Mensagem: "em Belo Horizonte" -> {"cidade": "belo horizonte", "bairro": null, "zona": null, "confidence": 0.95}
- Mensagem: "centro de SP" -> {"cidade": "são paulo", "bairro": null, "zona": "centro", "confidence": 0.9}
- Mensagem: "perto do metrô" -> {"cidade": null, "bairro": null, "zona": null, "confidence": 0.8}

Mensagem do usuário: "{$userMessage}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/ExtractLocationPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

/**
 * Constrói o prompt para a IA extrair uma localização da mensagem do usuário.
 */
class ExtractLocationPrompt
{
    public function build(string $user_message): string
    {
        return <<<PROMPT
Você é um assistente especialista em agendamentos de Pés Sem Dor no Brasil, fluente em português brasileiro.

Pense passo a passo: 1. Identifique menções a estados, cidades, bairros ou CEP. 2. Normalize valores (ex: "Sao Paulo" para "SP"). 3. Avalie confiança.

Analise a mensagem do usuário e extraia uma sigla de estado brasileiro (UF com 2 letras), um CEP (8 dígitos), cidade ou bairro.

Responda APENAS com um objeto JSON: {"type": "state/cep/city/neighborhood/unknown", "value": string/null, "confidence": número}.

Exemplos:
- Mensagem: "sou de minas gerais" -> {"type": "state", "value": "MG", "confidence": 1.0}
- Mensagem: "meu cep é 01001-000" -> {"type": "cep", "value": "01001000", "confidence": 1.0}
- Mensagem: "Estou em São Paulo" -> {"type": "state", "value": "SP", "confidence": 1.0}
- Mensagem: "quero agendar" -> {"type": "unknown", "value": null, "confidence": 1.0}
- Mensagem: "tô no Rio" -> {"type": "state", "value": "RJ", "confidence": 0.95}
- Mensagem: "em Pinheiros" -> {"type": "neighborhood", "value": "Pinheiros", "confidence": 1.0}
- Mensagem: "Campinas é boa?" -> {"type": "city", "value": "Campinas", "confidence": 0.9}
- Mensagem: "zona sul de Sampa" -> {"type": "neighborhood", "value": "zona sul", "confidence": 0.85}

Mensagem do usuário: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/FilterUnitsPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

/**
 * Constrói o prompt para a IA filtrar uma lista de unidades ou responder a perguntas específicas sobre elas.
 */
class FilterUnitsPrompt
{
    public function build(string $user_question, array $units): string
    {
        $unit_list_json = json_encode($units, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);

        return <<<PROMPT
Você é um assistente especialista em agendamentos da Pés Sem Dor no Brasil, fluente em português brasileiro.

Pense passo a passo: 1. Analise a mensagem para escolha ou pergunta. 2. Compare com a lista de unidades. 3. Avalie confiança; se ambíguo, explique em "answer".

A lista de unidades relevantes está abaixo, em formato JSON:
{$unit_list_json}

A mensagem do usuário é: "{$user_question}"

Sua tarefa é decidir entre: 1. ESCOLHA DE UNIDADE (retorne "choice" com objeto completo). 2. PERGUNTA SOBRE A LISTA (retorne "answer" com texto).

Responda APENAS com JSON: {"choice": objeto/null, "answer": string/null, "confidence": número}.

Exemplos:
- Mensagem: "unidade Osasco" -> {"choice": { ... }, "answer": null, "confidence": 1.0}
- Mensagem: "qual o endereço da de Osasco?" -> {"choice": null, "answer": "O endereço é Av. dos Autonomistas, 896, Sala 301.", "confidence": 1.0}
- Mensagem: "a do Tatuapé" -> {"choice": { ... }, "answer": null, "confidence": 0.95}
- Mensagem: "tem na zona leste?" -> {"choice": null, "answer": "Sim, temos unidades em Tatuapé e Vila Carrão.", "confidence": 0.9}
- Mensagem: "qual a mais perto do CEP 01000?" -> {"choice": null, "answer": "A unidade Centro é a mais próxima.", "confidence": 0.85}
- Mensagem: "não sei, explica" -> {"choice": null, "answer": "Por favor, especifique uma unidade ou pergunta.", "confidence": 0.8}

PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/FunctionResponseFormatterPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class FunctionResponseFormatterPrompt
{
    /**
     * Constrói o prompt para formatar dados de API em uma resposta natural.
     *
     * @param string $api_data Os dados brutos da API (em formato JSON).
     * @param string $conversation_history O histórico da conversa.
     * @return string O prompt formatado.
     */
    public function build(string $api_data, string $conversation_history): string
    {
        return <<<PROMPT
## Contexto ##
Você é um assistente de agendamento. Você recebeu a CONVERSA entre o Cliente e o Atendente, e INFORMAÇÕES AUXILIARES de uma função interna do sistema.

## Tarefa ##
1. Use as INFORMAÇÕES AUXILIARES para formular uma resposta clara e útil para o cliente, dando continuidade à CONVERSA.

## Regras ##
1. A resposta deve ser em linguagem natural, como se fosse um atendente humano.
2. Não mencione as "informações auxiliares" ou a palavra "JSON" na sua resposta.
3. Se a lista de informações estiver vazia, informe ao cliente que não encontrou o que ele pediu e pergunte se ele gostaria de tentar de outra forma.

## Conversa ##
{$conversation_history}

## Informações Auxiliares ##
{$api_data}
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/GeneralIntentPrompt.php
================================================
[Binary file]


================================================
FILE: app/Chat/Prompts/IsAffirmativePrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class IsAffirmativePrompt
{
    /**
     * Constrói o prompt para verificar se uma mensagem é afirmativa.
     *
     * @param string $message A mensagem do utilizador.
     * @return string
     */
    public function build(string $message): string
    {
        return <<<PROMPT
A mensagem do utilizador é uma afirmação, concordância ou resposta positiva?
Responda APENAS com a palavra 'sim' ou 'não'.

Exemplos:
- Mensagem: "sim, pode ser" -> sim
- Mensagem: "quero sim" -> sim
- Mensagem: "claro" -> sim
- Mensagem: "não, obrigado" -> não
- Mensagem: "acho que não" -> não

Mensagem do utilizador: "{$message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/IsNegativePrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class IsNegativePrompt
{
    /**
     * Constrói o prompt para verificar se uma mensagem é uma negação.
     *
     * @param string $message A mensagem do utilizador.
     * @return string
     */
    public function build(string $message): string
    {
        return <<<PROMPT
A mensagem do utilizador é uma negação, discordância ou resposta negativa?
Responda APENAS com a palavra 'sim' ou 'não'.

Exemplos:
- Mensagem: "não, obrigado" -> sim
- Mensagem: "deixa pra lá" -> sim
- Mensagem: "não quero" -> sim
- Mensagem: "pode ser" -> não
- Mensagem: "sim, por favor" -> não

Mensagem do utilizador: "{$message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/IsQuestionPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class IsQuestionPrompt
{
    /**
     * Constrói o prompt para verificar se uma mensagem é uma pergunta.
     *
     * @param string $message A mensagem do utilizador.
     * @return string
     */
    public function build(string $message): string
    {
        return <<<PROMPT
A mensagem do utilizador é uma pergunta?
Responda APENAS com a palavra 'sim' ou 'não'.

Exemplos:
- Mensagem: "quanto custa?" -> sim
- Mensagem: "tem horário amanhã?" -> sim
- Mensagem: "e se for na sexta?" -> sim
- Mensagem: "quero agendar" -> não
- Mensagem: "pode ser às 15h" -> não

Mensagem do utilizador: "{$message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/OrchestrationPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class OrchestrationPrompt
{
    // ALTERADO: Agora recebe histórico como parâmetro opcional
    public function build(string $user_message, string $history = ''): string
    {
        $possible_intents = implode("', '", ['agendamento', 'consultar_agendamento', 'cancelamento', 'informacao_geral', 'saudacao', 'afirmativa', 'negativa']);

        return <<<PROMPT
Você é um assistente especialista em agendamentos da Pés Sem Dor no Brasil, fluente em português brasileiro.

Pense passo a passo: 1. Revise o histórico da conversa para contexto. 2. Classifique intenção. 3. Verifique se é pergunta. 4. Extraia localização (incluindo zona). 5. Avalie confiança.

Histórico da conversa (considere para contexto):
{$history}

Retorne JSON: {"intent": "string", "is_question": boolean, "location": {"type": "string", "value": "string"}|null, "confidence": número}.

Opções de intent: '{$possible_intents}' ou 'desconhecida'.

Exemplos:
- Histórico: Bot: Gostaria de agendar uma avaliação gratuita? Mensagem: "Gostaria" -> {"intent": "afirmativa", "is_question": false, "location": null, "confidence": 1.0}
- Mensagem: "quais as opções no rio de janeiro?" -> {"intent": "informacao_geral", "is_question": true, "location": {"type": "state", "value": "RJ"}, "confidence": 1.0}
- Mensagem: "Gostaria de agendar em SP" -> {"intent": "agendamento", "is_question": false, "location": {"type": "state", "value": "SP"}, "confidence": 1.0}
- Mensagem: "tem em Campinas?" -> {"intent": "informacao_geral", "is_question": true, "location": {"type": "city", "value": "Campinas"}, "confidence": 1.0}
- Mensagem: "e no bairro de Moema?" -> {"intent": "informacao_geral", "is_question": true, "location": {"type": "neighborhood", "value": "Moema"}, "confidence": 1.0}
- Mensagem: "meu cep é 01001-000" -> {"intent": "informacao_geral", "is_question": false, "location": {"type": "cep", "value": "01001000"}, "confidence": 1.0}
- Mensagem: "quero agendar" -> {"intent": "agendamento", "is_question": false, "location": null, "confidence": 1.0}
- Mensagem: "na zona sul de SP" -> {"intent": "informacao_geral", "is_question": true, "location": {"type": "zona", "value": "zona sul"}, "confidence": 0.95}
- Mensagem: "sim, confirma" -> {"intent": "afirmativa", "is_question": false, "location": null, "confidence": 0.9}

Mensagem atual: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/OrchestratorPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class OrchestratorPrompt
{
    /**
     * Constrói o prompt para o orquestrador principal da IA.
     *
     * @param string $user_message A mensagem atual do usuário.
     * @param string $history O histórico formatado da conversa.
     * @return string O prompt formatado.
     */
    public function build(string $user_message, string $history = ''): string
    {
        $possible_intents = implode("', '", [
            'agendamento',
            'consultar_agendamento',
            'cancelamento',
            'informacao_geral',
            'saudacao',
            'afirmativa',
            'negativa',
            'desconhecida'
        ]);

        return <<<PROMPT
## Contexto ##
Você é um Orquestrador de um chatbot de agendamento. Sua tarefa é analisar a MENSAGEM DO CLIENTE e o HISTÓRICO da conversa para classificar a intenção principal.

## Tarefa ##
1. Pense passo a passo para determinar a intenção mais provável.
2. Analise o HISTÓRICO para entender o contexto.
3. Classifique a MENSAGEM DO CLIENTE em uma das categorias da LISTA.
4. Atribua um score de confiança (confidence) de 0.0 a 1.0.

## Saída ##
Forneça a resposta APENAS em formato JSON: {"intent": "categoria", "confidence": 1.0}

## Lista de Intenções ##
'{$possible_intents}'

## Histórico ##
{$history}

MENSAGEM DO CLIENTE: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/ScopeCheckPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class ScopeCheckPrompt
{
    public function build(string $user_message): string
    {
        return <<<PROMPT
Você é um assistente especialista em agendamentos da Pés Sem Dor no Brasil, fluente em português brasileiro.

Pense passo a passo: 1. Verifique se relacionado a agendamentos, horários, unidades, endereço, saúde dos pés ou saudação. 2. Avalie confiança e razão.

Responda APENAS com JSON: {"in_scope": "yes/no", "reason": "string", "confidence": número}.

Exemplos:
- Mensagem: "quero agendar" -> {"in_scope": "yes", "reason": "relacionado a agendamento", "confidence": 1.0}
- Mensagem: "dor no pé" -> {"in_scope": "yes", "reason": "saúde dos pés", "confidence": 0.9}
- Mensagem: "pedir pizza" -> {"in_scope": "no", "reason": "assunto aleatório", "confidence": 1.0}
- Mensagem: "oi, sobre palmilhas?" -> {"in_scope": "yes", "reason": "saudação e saúde", "confidence": 0.95}

Mensagem: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/SentimentAnalysisPrompt.php
================================================
<?php

namespace App\Chat\Prompts;

class SentimentAnalysisPrompt
{
    /**
     * Constrói o prompt para a IA classificar o sentimento de uma mensagem.
     *
     * @param string $user_message A mensagem do cliente.
     * @return string O prompt formatado.
     */
    public function build(string $user_message): string
    {
        $candidate_labels = '["Muito insatisfeito", "Insatisfeito", "Neutro", "Satisfeito", "Muito satisfeito"]';

        return <<<PROMPT
## Contexto ##
Você é um especialista em análise de sentimento. Sua tarefa é classificar a MENSAGEM DO CLIENTE em uma das categorias fornecidas.

## Tarefas ##
1. Identifique a categoria à qual a MENSAGEM DO CLIENTE pertence com a maior probabilidade.
2. Atribua apenas 1 categoria.
3. Forneça sua resposta como um arquivo JSON contendo uma única chave "label" e o valor correspondente à categoria atribuída. Não forneça qualquer informação adicional.

## Saída ##
Arquivo JSON de saída: {"label": "categoria"}

## Lista ##
Lista de categorias: {$candidate_labels}

## Regras ##
- A MENSAGEM DO CLIENTE pertence a apenas 1 categoria.
- Classifique como 'Muito insatisfeito' se o cliente escrever expressões ofensivas.
- Classifique como 'Insatisfeito' se o cliente demonstrar um sentimento negativo em relação à experiência.
- Classifique como 'Neutro' se o cliente denotar uma postura neutra.
- Classifique como 'Satisfeito' se o cliente apresentar um sentimento positivo.
- Classifique como 'Muito satisfeito' se o cliente fizer elogios ou manifestações de felicidade.

MENSAGEM DO CLIENTE: "{$user_message}"
PROMPT;
    }
}



================================================
FILE: app/Chat/Prompts/UnitChoicePrompt.php
================================================
<?php

namespace App\Chat\Prompts;

/**
 * Constrói o prompt para a IA identificar qual unidade o usuário escolheu de uma lista.
 */
class UnitChoicePrompt
{
    public function build(string $user_message, array $units): string
    {
        $unit_list_for_prompt = "";
        foreach ($units as $index => $unit) {
            $unit_list_for_prompt .= ($index + 1) . ". " . $unit['nomeFranquia'] . " (" . $unit['bairroFranquia'] . ", " . $unit['cidadeFranquia'] . ")\n";
        }

        return <<<PROMPT
Você é um assistente especialista em agendamentos da Pés Sem Dor no Brasil, fluente em português brasileiro.

Pense passo a passo: 1. Analise referências a nomes, bairros ou números. 2. Compare com a lista. 3. Avalie confiança; se ambíguo, retorne null.

Lista de Unidades Apresentadas:
{$unit_list_for_prompt}

Mensagem do usuário: "{$user_message}"

Responda APENAS com JSON: {"choice": objeto/null, "confidence": número}.

Exemplos:
- Mensagem: "Unidade Santana" -> {"choice": { ... }, "confidence": 1.0}
- Mensagem: "a número 9" -> {"choice": { ... }, "confidence": 1.0}
- Mensagem: "e no Ipiranga?" -> {"choice": null, "confidence": 0.9}
- Mensagem: "qual o endereço da primeira?" -> {"choice": null, "confidence": 1.0}
- Mensagem: "a de Moema" -> {"choice": { ... }, "confidence": 0.95}
- Mensagem: "zona sul, a segunda" -> {"choice": { ... }, "confidence": 0.85}
- Mensagem: "não gostei, outra" -> {"choice": null, "confidence": 0.8}

PROMPT;
    }
}



================================================
FILE: app/Data/ConversationAnalysisDTO.php
================================================
<?php

namespace App\Data;

use Spatie\LaravelData\Data;
use Spatie\LaravelData\Attributes\Validation\In;

class ConversationAnalysisDTO extends Data
{
    public function __construct(
        #[In(['agendamento', 'consultar_agendamento', 'cancelamento', 'reagendamento', 'saudacao', 'informacao_geral', 'desconhecida'])]
        public string $intent,
        public float $confidence,
    ) {}
}



================================================
FILE: app/Data/EntityExtractionDTO.php
================================================
<?php

namespace App\Data;

use Spatie\LaravelData\Data;
use Spatie\LaravelData\Attributes\Validation\Nullable;

/**
 * DTO para armazenar as entidades extraídas da mensagem do usuário.
 */
class EntityExtractionDTO extends Data
{
    public function __construct(
        #[Nullable]
        public ?string $name,
        #[Nullable]
        public ?string $phone,
        #[Nullable]
        public ?string $date,
        #[Nullable]
        public ?string $time,
        #[Nullable]
        public ?string $location_type, // ex: 'state', 'city', 'cep'
        #[Nullable]
        public ?string $location_value,
        #[Nullable]
        public ?string $unit_name,
        #[Nullable]
        public ?string $correction_field,
    ) {}
}



================================================
FILE: app/Data/LocationDTO.php
================================================
<?php

namespace App\Data;

use Spatie\LaravelData\Data;
use Spatie\LaravelData\Attributes\Validation\In;
use Spatie\LaravelData\Attributes\Validation\Required;
use Spatie\LaravelData\Attributes\Validation\Nullable;

class LocationDTO extends Data
{
    public function __construct(
        #[Required]
        #[In(['state', 'cep', 'unknown'])]
        public string $type,

        #[Nullable]
        public ?string $value,
    ) {}
}



================================================
FILE: app/Events/ChatMessageSent.php
================================================
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class ChatMessageSent implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public string $userId;
    public string $responseMessage;

    /**
     * Cria uma nova instância do evento.
     *
     * @param string $userId
     * @param string $responseMessage
     */
    public function __construct(string $userId, string $responseMessage)
    {
        $this->userId = $userId;
        $this->responseMessage = $responseMessage;
    }

    /**
     * Obtém os canais nos quais o evento deve ser transmitido.
     *
     * Usamos um canal público onde o nome do canal é o próprio ID do usuário (session_id),
     * garantindo que a mensagem só seja entregue para o cliente correto.
     *
     * @return \Illuminate\Broadcasting\Channel|array
     */
    public function broadcastOn()
    {
        return new Channel('chat.' . $this->userId);
    }

    /**
     * O nome do evento a ser transmitido.
     *
     * @return string
     */
    public function broadcastAs()
    {
        return 'message.sent';
    }
}



================================================
FILE: app/Http/Controllers/ApiChatController.php
================================================
<?php

namespace App\Http\Controllers;

use App\Jobs\ProcessChatMessage;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;

class ApiChatController extends Controller
{
    public function handle(Request $request): JsonResponse
    {
        // 1. Valida os dados da requisição, incluindo o novo campo de telefone.
        $validator = Validator::make($request->all(), [
            'message' => 'required|string|max:4000',
            'user_id' => 'required|string|max:255',
            'phone_number' => 'nullable|string|max:20', // NOVO: Validação para o telefone
        ]);

        if ($validator->fails()) {
            return response()->json(['errors' => $validator->errors()], 422);
        }

        $validatedData = $validator->validated();

        // 2. Despacha o job para a fila, passando o telefone como um novo parâmetro.
        ProcessChatMessage::dispatch(
            $validatedData['message'],
            $validatedData['user_id'],
            'web', // O canal é 'web' para este controller.
            $validatedData['phone_number'] ?? null
        );

        // 3. Retorna uma resposta imediata de sucesso.
        return response()->json([
            'status' => 'success',
            'message' => 'Message received and queued for processing.'
        ], 202);
    }
}



================================================
FILE: app/Http/Controllers/Controller.php
================================================
<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}



================================================
FILE: app/Http/Controllers/WebChatController.php
================================================
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Adapters\Ai\AiAdapterInterface;

class WebChatController extends Controller
{
    /**
     * Exibe a interface do chat.
     */
    public function show()
    {
        $history = session('chat_history', []);
        return view('webchat', ['history' => $history]);
    }

    /**
     * Processa a mensagem enviada pelo usuário.
     */
    public function store(Request $request, AiAdapterInterface $aiAdapter)
    {
        $request->validate(['message' => 'required|string|max:2000']);

        $user_message = $request->input('message');
        $sessionId = session()->getId();

        // Adiciona a mensagem do usuário à sessão
        app('App\Adapters\Messaging\WebAdapter')->processIncoming($request);

        // Envia para a IA utilizando o método getChat
        $aiResponse = $aiAdapter->getChat($user_message, $sessionId);

        // Salva a resposta da IA na sessão
        app('App\Adapters\Messaging\WebAdapter')->sendResponse($sessionId, $aiResponse);

        return redirect()->route('chat.show');
    }

    /**
     * Limpa o histórico do chat da sessão.
     */
    public function clear()
    {
        session()->forget('chat_history');
        return redirect()->route('chat.show');
    }
}



================================================
FILE: app/Http/Controllers/WebhookController.php
================================================
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Adapters\Ai\AiAdapterInterface;
use App\Adapters\Messaging\MessagingAdapterInterface;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Log;

/**
 * Class WebhookController
 *
 * Ponto de entrada para todas as requisições de webhooks das plataformas de mensagens.
 */
class WebhookController extends Controller
{
    /**
     * Manipula a requisição de entrada do webhook.
     */
    public function handle(
        Request $request,
        AiAdapterInterface $aiAdapter,
        MessagingAdapterInterface $messagingAdapter
    ): JsonResponse {
        try {
            // Passo 1: O adaptador de mensagens processa a requisição bruta
            $processedMessage = $messagingAdapter->processIncoming($request);

            if (empty($processedMessage['message'])) {
                Log::info('Requisição de webhook ignorada (sem mensagem de texto).');
                return response()->json(['status' => 'ignored', 'reason' => 'No text message found']);
            }

            // Passo 2: A mensagem padronizada é enviada para o adaptador de IA
            // MODIFICADO: Utiliza o método getChat, passando o senderId como sessionId
            $aiResponse = $aiAdapter->getChat($processedMessage['message'], $processedMessage['senderId']);

            // Passo 3: A resposta da IA é enviada de volta para o usuário
            $messagingAdapter->sendResponse($processedMessage['senderId'], $aiResponse);

            return response()->json(['status' => 'success']);
        } catch (\Exception $e) {
            Log::error('Erro no WebhookController: ' . $e->getMessage(), [
                'trace' => $e->getTraceAsString()
            ]);

            return response()->json(['status' => 'error', 'message' => 'Ocorreu um erro interno.'], 500);
        }
    }
}



================================================
FILE: app/Jobs/ProcessChatMessage.php
================================================
<?php

namespace App\Jobs;

use App\Chat\ChatApplicationManager;
use App\Chat\SentimentAnalyzerService;
use App\Events\ChatMessageSent;
use App\Models\ChatSession;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Throwable;

class ProcessChatMessage implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 3;
    public int $backoff = 5;

    protected string $message;
    protected string $session_id;
    protected string $channel;
    protected ?string $phone_number;

    public function __construct(string $message, string $session_id, string $channel, ?string $phone_number = null)
    {
        $this->message = $message;
        $this->session_id = $session_id;
        $this->channel = $channel;
        $this->phone_number = $phone_number;
    }

    public function handle(ChatApplicationManager $chat_manager, SentimentAnalyzerService $sentiment_analyzer): void
    {
        Log::info('[INÍCIO] Iniciando job ProcessChatMessage.', [
            'session_id' => $this->session_id,
            'phone_number' => $this->phone_number,
            'channel' => $this->channel,
            'message' => $this->message,
        ]);

        try {
            $session = ChatSession::firstOrCreate(
                ['id' => $this->session_id],
                ['phone_number' => $this->phone_number]
            );

            if ($this->phone_number && !$session->phone_number) {
                $session->phone_number = $this->phone_number;
                $session->save();
            }
            Log::info('[PASSO 1/4] Sessão de chat carregada.', ['session_id' => $session->id]);

            $session->addToHistory('user', $this->message);

            $response_message = $chat_manager->handle($session, $this->message, $this->channel);
            Log::info('[PASSO 2/4] Resposta do ChatApplicationManager recebida.', [
                'response' => $response_message ?? 'NULA'
            ]);

            if ($response_message) {
                $session->addToHistory('bot', $response_message);

                $sentiment = $sentiment_analyzer->analyze($this->message, $this->session_id);
                if ($sentiment) {
                    $session->last_sentiment = $sentiment;
                }

                $state = $session->state ?? [];
                $state['last_bot_message'] = $response_message;
                $session->state = $state;
                $session->save();

                Log::info('[PASSO 3/4] Despachando evento para o Reverb...');
                ChatMessageSent::dispatch($this->session_id, $response_message);
                Log::info('[PASSO 4/4] Evento ChatMessageSent despachado.', ['session_id' => $this->session_id]);
            } else {
                Log::warning('[PASSO 3/4] Resposta do chat está vazia. Nenhum evento despachado.');
            }

            Log::info('[FIM] Job ProcessChatMessage concluído com sucesso.', ['session_id' => $session->id]);
        } catch (Throwable $exception) {
            $this->failed($exception);
            throw $exception;
        }
    }

    public function failed(Throwable $exception): void
    {
        Log::critical('[FALHA] Falha crítica no job ProcessChatMessage', [
            'session_id' => $this->session_id,
            'phone_number' => $this->phone_number,
            'exception_message' => $exception->getMessage(),
            'trace' => $exception->getTraceAsString(),
        ]);
    }
}



================================================
FILE: app/Models/ChatSession.php
================================================
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

/**
 * Representa uma sessão de conversa do chatbot.
 */
class ChatSession extends Model
{
    use HasFactory, HasUuids;

    /**
     * O nome da tabela associada ao modelo.
     *
     * @var string
     */
    protected $table = 'chat_sessions';

    /**
     * Os atributos que podem ser atribuídos em massa.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'id',
        'phone_number',
        'state',
        'history',
        'last_sentiment',
    ];

    /**
     * Os atributos que devem ser convertidos para tipos nativos.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'state' => 'array',
        'history' => 'array',
    ];

    /**
     * Obtém o histórico formatado como string para prompts.
     *
     * @return string
     */
    public function getFormattedHistory(): string
    {
        $formatted = '';
        foreach ($this->history ?? [] as $entry) {
            // A "role" do bot deve ser "assistant" para a API da OpenAI
            $role_name = ($entry['role'] === 'bot' || $entry['role'] === 'assistant') ? 'assistant' : 'user';
            $formatted .= ucfirst($role_name) . ": " . $entry['content'] . "\n";
        }
        return $formatted;
    }

    /**
     * Adiciona uma entrada ao histórico e limita às últimas 5 para otimização.
     *
     * @param string $role
     * @param string $content
     * @return void
     */
    public function addToHistory(string $role, string $content): void
    {
        $history = $this->history ?? [];
        // Garante que o role 'bot' seja sempre 'assistant' no histórico
        $history[] = ['role' => ($role === 'bot' ? 'assistant' : $role), 'content' => $content];
        $this->history = array_slice($history, -5);
        $this->save();
    }
}



================================================
FILE: app/Models/User.php
================================================
<?php

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

class User extends Authenticatable
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasFactory, Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var list<string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
        ];
    }
}



================================================
FILE: app/Providers/AppServiceProvider.php
================================================
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        //
    }

    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        //
    }
}



================================================
FILE: app/Providers/ChatbotServiceProvider.php
================================================
<?php

namespace App\Providers;

use App\Adapters\Ai\AiAdapterInterface;
use App\Adapters\Ai\ChatGPTAdapter;
use App\Adapters\Ai\PrismAdapter;
use App\Adapters\Messaging\MessagingAdapterInterface;
use App\Adapters\Messaging\WebAdapter;
use App\Adapters\Messaging\WhatsAppAdapter;
use App\Chat\Applications\BookingApplication;
use App\Chat\Applications\ExistingAppointmentApplication;
use App\Chat\Applications\GreetingApplication;
use App\Chat\SentimentAnalyzerService;
use App\Chat\ChatApplicationManager;
use App\Chat\Flows\BookingFlow\StateHandlerFactory;
use App\Chat\PromptManager;
use Illuminate\Support\ServiceProvider;
use InvalidArgumentException;

class ChatbotServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        // --- REGISTO DOS ADAPTADORES ---
        $this->app->singleton(AiAdapterInterface::class, function ($app) {
            return new PrismAdapter();
        });

        $this->app->singleton(MessagingAdapterInterface::class, function ($app) {
            $adapter = config('services.messaging.adapter');
            switch ($adapter) {
                case 'whatsapp':
                    return new WhatsAppAdapter();
                case 'web':
                    return new WebAdapter();
                default:
                    throw new InvalidArgumentException("Adaptador de Mensagens inválido: {$adapter}");
            }
        });

        // --- REGISTO DOS MANAGERS E FACTORIES ---
        $this->app->singleton(ChatApplicationManager::class);
        $this->app->singleton(StateHandlerFactory::class);
        $this->app->singleton(PromptManager::class);
        $this->app->singleton(SentimentAnalyzerService::class);

        // --- REGISTO E ETIQUETAGEM DAS APLICAÇÕES DE CHAT ---
        $this->app->singleton(GreetingApplication::class);
        $this->app->tag(GreetingApplication::class, 'chatbot.application');

        $this->app->singleton(BookingApplication::class);
        $this->app->tag(BookingApplication::class, 'chatbot.application');

        $this->app->singleton(ExistingAppointmentApplication::class);
        $this->app->tag(ExistingAppointmentApplication::class, 'chatbot.application');
    }

    public function boot(): void
    {
        //
    }
}



================================================
FILE: app/Providers/TelescopeServiceProvider.php
================================================
<?php

namespace App\Providers;

use Illuminate\Support\Facades\Gate;
use Laravel\Telescope\IncomingEntry;
use Laravel\Telescope\Telescope;
use Laravel\Telescope\TelescopeApplicationServiceProvider;

class TelescopeServiceProvider extends TelescopeApplicationServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        // Telescope::night();

        $this->hideSensitiveRequestDetails();

        $isLocal = $this->app->environment('local');

        Telescope::filter(function (IncomingEntry $entry) use ($isLocal) {
            return $isLocal ||
                   $entry->isReportableException() ||
                   $entry->isFailedRequest() ||
                   $entry->isFailedJob() ||
                   $entry->isScheduledTask() ||
                   $entry->hasMonitoredTag();
        });
    }

    /**
     * Prevent sensitive request details from being logged by Telescope.
     */
    protected function hideSensitiveRequestDetails(): void
    {
        if ($this->app->environment('local')) {
            return;
        }

        Telescope::hideRequestParameters(['_token']);

        Telescope::hideRequestHeaders([
            'cookie',
            'x-csrf-token',
            'x-xsrf-token',
        ]);
    }

    /**
     * Register the Telescope gate.
     *
     * This gate determines who can access Telescope in non-local environments.
     */
    protected function gate(): void
    {
        Gate::define('viewTelescope', function ($user) {
            return in_array($user->email, [
                //
            ]);
        });
    }
}



================================================
FILE: app/Services/GoogleMapsService.php
================================================
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

class GoogleMapsService
{
    protected string $api_key;
    protected string $base_url = 'https://maps.googleapis.com/maps/api/geocode/json';

    public function __construct()
    {
        $this->api_key = config('services.google_maps.api_key');
    }

    /**
     * Obtém as coordenadas (latitude e longitude) a partir de um CEP.
     *
     * @param string $cep O CEP a ser pesquisado.
     * @return array|null Um array com 'latitude' e 'longitude' ou nulo em caso de falha.
     */
    public function getCoordinatesFromCep(string $cep): ?array
    {
        if (empty($this->api_key)) {
            Log::error('A chave da API do Google Maps não está configurada.');
            return null;
        }

        $cep_limpo = preg_replace('/\D/', '', $cep);

        try {
            $response = Http::get($this->base_url, [
                'address' => $cep_limpo,
                'key' => $this->api_key,
                'region' => 'BR'
            ]);

            if ($response->successful() && $response->json('status') === 'OK') {
                $location = $response->json('results.0.geometry.location');
                if ($location) {
                    return [
                        'latitude' => $location['lat'],
                        'longitude' => $location['lng'],
                    ];
                }
            }

            Log::warning('Não foi possível obter coordenadas para o CEP.', [
                'cep' => $cep,
                'response_status' => $response->json('status'),
                'response_body' => $response->body()
            ]);
            return null;
        } catch (\Exception $e) {
            Log::error('Exceção ao chamar a API do Google Maps Geocoding.', [
                'cep' => $cep,
                'error' => $e->getMessage()
            ]);
            return null;
        }
    }
}



================================================
FILE: app/Services/SchedulingService.php
================================================
<?php

namespace App\Services;

use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Carbon\Carbon;
use Illuminate\Support\Str;

class SchedulingService
{
    protected string $url_base_api;
    protected string $token_api;
    const CHAVE_CACHE_UNIDADES = 'todas_unidades_ativas';

    public function __construct()
    {
        $this->url_base_api = config('services.scheduling_api.base_url');
        $this->token_api = config('services.scheduling_api.token');
    }

    /**
     * Obtém a lista de unidades do cache.
     * Este é um método de conveniência que chama obterTodasAsUnidadesAtivas.
     *
     * @return array A lista de unidades.
     */
    public function getUnidades(): array
    {
        return $this->obterTodasAsUnidadesAtivas();
    }

    /**
     * Busca todas as unidades ativas da API e as armazena em um cache global.
     * A consulta à API só ocorre se o cache não existir ou estiver expirado.
     *
     * @return array A lista de todas as unidades ativas.
     */
    public function obterTodasAsUnidadesAtivas(): array
    {
        // O cache agora dura 4 horas (240 minutos)
        $duracao_cache = now()->addMinutes(240);

        return Cache::remember(self::CHAVE_CACHE_UNIDADES, $duracao_cache, function () {
            $url = "{$this->url_base_api}/agenda-parceiro/unidades/token/{$this->token_api}";
            Log::info('--- CACHE GLOBAL EXPIRADO. BUSCANDO UNIDADES DA API. ---', ['url' => $url]);
            try {
                $resposta = Http::withoutVerifying()->timeout(60)->get($url);

                if ($resposta->successful()) {
                    $unidades = $resposta->json() ?? [];
                    Log::info('Unidades armazenadas no cache global com sucesso.', ['total_unidades' => count($unidades)]);
                    return $unidades;
                }

                Log::error("Falha ao buscar a lista de unidades da API para o cache global.", ['status' => $resposta->status()]);
                return [];
            } catch (\Exception $e) {
                Log::error("Exceção ao buscar a lista de unidades da API: " . $e->getMessage());
                return [];
            }
        });
    }

    /**
     * NOVO: Busca a unidade mais próxima com base na latitude e longitude.
     *
     * @param float $latitude A latitude para a busca.
     * @param float $longitude A longitude para a busca.
     * @return array|null Os dados da unidade mais próxima ou nulo em caso de falha.
     */
    public function obterUnidadeMaisProxima(float $latitude, float $longitude): ?array
    {
        $url = "{$this->url_base_api}/agenda-parceiro/unidade-mais-proxima/latitude/{$latitude}/longitude/{$longitude}/token/{$this->token_api}";
        Log::info('Buscando unidade mais próxima na API.', ['url' => $url]);

        try {
            $resposta = Http::withoutVerifying()->timeout(30)->get($url);

            if ($resposta->successful() && !empty($resposta->json())) {
                $unidade = $resposta->json();
                Log::info('Unidade mais próxima encontrada.', ['unidade' => $unidade['nomeFranquia']]);
                return $unidade;
            }

            Log::warning('Nenhuma unidade próxima encontrada ou falha na API.', [
                'status' => $resposta->status(),
                'body' => $resposta->body()
            ]);
            return null;
        } catch (\Exception $e) {
            Log::error("Exceção ao buscar unidade mais próxima: " . $e->getMessage());
            return null;
        }
    }

    /**
     * Filtra uma lista de unidades com base nos critérios fornecidos.
     *
     * @param array $unidades_para_filtrar A lista de unidades a ser filtrada.
     * @param string|null $estado O estado para filtrar (ex: "SP").
     * @param string|null $cidade A cidade para filtrar.
     * @param string|null $bairro O bairro para filtrar.
     * @return array A lista de unidades filtrada.
     */
    public function filtrarUnidades(array $unidades_para_filtrar, ?string $estado = null, ?string $cidade = null, ?string $bairro = null): array
    {
        return array_filter($unidades_para_filtrar, function ($unidade) use ($estado, $cidade, $bairro) {
            $match = true;
            if ($estado && !Str::contains(Str::lower($unidade['estadoFranquia']), Str::lower($estado))) {
                $match = false;
            }
            if ($cidade && !Str::contains(Str::lower($unidade['cidadeFranquia']), Str::lower($cidade))) {
                $match = false;
            }
            if ($bairro && !Str::contains(Str::lower($unidade['bairroFranquia']), Str::lower($bairro))) {
                $match = false;
            }
            return $match;
        });
    }

    public function buscarAgendamentoPorTelefone(string $numero_telefone): ?array
    {
        $telefone_limpo = preg_replace('/\D/', '', $numero_telefone);
        $url = "{$this->url_base_api}/agenda-parceiro/buscar-telefone";

        try {
            $resposta = Http::asForm()->withoutVerifying()->post($url, [
                'token' => $this->token_api,
                'telefone' => $telefone_limpo,
            ]);

            if ($resposta->successful()) {
                $dados = $resposta->json();
                if (isset($dados['resposta']['sucesso']) && $dados['resposta']['sucesso'] === true) {
                    return $dados['resposta'];
                }
            }
            return null;
        } catch (\Exception $e) {
            Log::error("ERRO DE EXCEÇÃO ao buscar agendamento por telefone: " . $e->getMessage());
            return null;
        }
    }

    public function obterHorariosDisponiveisPorPeriodo(string $grupo_franquia): array
    {
        $data_inicio = Carbon::now()->format('Y-m-d');
        $data_fim = Carbon::now()->addDays(5)->format('Y-m-d');
        $url = "{$this->url_base_api}/agenda-parceiro/vagas-disponiveis-periodo/local/{$grupo_franquia}/data_inicial/{$data_inicio}/data_final/{$data_fim}/token/{$this->token_api}";

        try {
            $resposta = Http::withoutVerifying()->timeout(30)->get($url);
            return $resposta->successful() ? $resposta->json() ?? [] : [];
        } catch (\Exception $e) {
            Log::error("ERRO DE EXCEÇÃO ao buscar vagas para {$grupo_franquia}: " . $e->getMessage());
            return [];
        }
    }

    public function criarAgendamento(array $dados): array
    {
        $url = "{$this->url_base_api}/agenda-parceiro/agendar/";
        $payload = [
            'nome' => $dados['name'],
            'ddd_cel' => $dados['ddd'],
            'cel' => $dados['phone'],
            'currentData' => $dados['date'],
            'hora' => $dados['time'],
            'unidade' => $dados['unit_franchise_group'],
            'token' => $this->token_api,
        ];

        // Adiciona o token de cancelamento ao payload se ele existir nos dados.
        // Isso é usado especificamente para o fluxo de reagendamento.
        if (!empty($dados['cancellation_token'])) {
            $payload['token_cancelamento'] = $dados['cancellation_token'];
        }

        try {
            $resposta = Http::asForm()->withoutVerifying()->post($url, $payload);
            return $resposta->successful() ? $resposta->json() ?? ['result' => 0] : ['result' => 0];
        } catch (\Exception $e) {
            Log::error("ERRO DE EXCEÇÃO ao criar agendamento: " . $e->getMessage(), ['payload' => $payload]);
            return ['result' => 0, 'success' => 'Ocorreu um erro inesperado.'];
        }
    }

    public function confirmarAgendamento(string $token_confirmacao): array
    {
        $url = "{$this->url_base_api}/agenda-parceiro/confirmar";
        Log::info('Tentando confirmar agendamento via POST.', ['url' => $url]);

        try {
            $resposta = Http::asForm()->withoutVerifying()->post($url, [
                'token' => $this->token_api,
                'token_agendamento' => $token_confirmacao,
            ]);
            return $resposta->json() ?? ['sucesso' => false];
        } catch (\Exception $e) {
            Log::error("ERRO DE EXCEÇÃO ao confirmar agendamento: " . $e->getMessage());
            return ['sucesso' => false, 'message' => 'Ocorreu um erro inesperado.'];
        }
    }

    public function cancelarAgendamento(string $token_cancelamento): array
    {
        $url = "{$this->url_base_api}/agenda-parceiro/cancelar";
        Log::info('Tentando cancelar agendamento via POST.', ['url' => $url]);

        try {
            $resposta = Http::asForm()->withoutVerifying()->post($url, [
                'token' => $this->token_api,
                'token_agendamento' => $token_cancelamento,
            ]);
            return $resposta->json() ?? ['sucesso' => false];
        } catch (\Exception $e) {
            Log::error("ERRO DE EXCEÇÃO ao cancelar agendamento: " . $e->getMessage());
            return ['sucesso' => false, 'message' => 'Ocorreu um erro inesperado.'];
        }
    }
}



================================================
FILE: bootstrap/app.php
================================================
<?php

use Illuminate\Foundation\Application;
use Illuminate\Foundation\Configuration\Exceptions;
use Illuminate\Foundation\Configuration\Middleware;

return Application::configure(basePath: dirname(__DIR__))
    ->withRouting(
        web: __DIR__.'/../routes/web.php',
        api: __DIR__.'/../routes/api.php',
        commands: __DIR__.'/../routes/console.php',
        channels: __DIR__.'/../routes/channels.php',
        health: '/up',
    )
    ->withMiddleware(function (Middleware $middleware): void {
        //
    })
    ->withExceptions(function (Exceptions $exceptions): void {
        //
    })->create();



================================================
FILE: bootstrap/providers.php
================================================
<?php

return [
    App\Providers\AppServiceProvider::class,
    App\Providers\ChatbotServiceProvider::class,
    App\Providers\TelescopeServiceProvider::class,
];



================================================
FILE: bootstrap/cache/packages.php
================================================
<?php return array (
  'laravel/pail' => 
  array (
    'providers' => 
    array (
      0 => 'Laravel\\Pail\\PailServiceProvider',
    ),
  ),
  'laravel/reverb' => 
  array (
    'aliases' => 
    array (
      'Output' => 'Laravel\\Reverb\\Output',
    ),
    'providers' => 
    array (
      0 => 'Laravel\\Reverb\\ApplicationManagerServiceProvider',
      1 => 'Laravel\\Reverb\\ReverbServiceProvider',
    ),
  ),
  'laravel/sail' => 
  array (
    'providers' => 
    array (
      0 => 'Laravel\\Sail\\SailServiceProvider',
    ),
  ),
  'laravel/sanctum' => 
  array (
    'providers' => 
    array (
      0 => 'Laravel\\Sanctum\\SanctumServiceProvider',
    ),
  ),
  'laravel/telescope' => 
  array (
    'providers' => 
    array (
      0 => 'Laravel\\Telescope\\TelescopeServiceProvider',
    ),
  ),
  'laravel/tinker' => 
  array (
    'providers' => 
    array (
      0 => 'Laravel\\Tinker\\TinkerServiceProvider',
    ),
  ),
  'nesbot/carbon' => 
  array (
    'providers' => 
    array (
      0 => 'Carbon\\Laravel\\ServiceProvider',
    ),
  ),
  'nunomaduro/collision' => 
  array (
    'providers' => 
    array (
      0 => 'NunoMaduro\\Collision\\Adapters\\Laravel\\CollisionServiceProvider',
    ),
  ),
  'nunomaduro/termwind' => 
  array (
    'providers' => 
    array (
      0 => 'Termwind\\Laravel\\TermwindServiceProvider',
    ),
  ),
  'prism-php/prism' => 
  array (
    'aliases' => 
    array (
      'PrismServer' => 'Prism\\Prism\\Facades\\PrismServer',
    ),
    'providers' => 
    array (
      0 => 'Prism\\Prism\\PrismServiceProvider',
    ),
  ),
  'spatie/laravel-data' => 
  array (
    'providers' => 
    array (
      0 => 'Spatie\\LaravelData\\LaravelDataServiceProvider',
    ),
  ),
  'spatie/php-structure-discoverer' => 
  array (
    'providers' => 
    array (
      0 => 'Spatie\\StructureDiscoverer\\StructureDiscovererServiceProvider',
    ),
  ),
);


================================================
FILE: bootstrap/cache/services.php
================================================
<?php return array (
  'providers' => 
  array (
    0 => 'Illuminate\\Auth\\AuthServiceProvider',
    1 => 'Illuminate\\Broadcasting\\BroadcastServiceProvider',
    2 => 'Illuminate\\Bus\\BusServiceProvider',
    3 => 'Illuminate\\Cache\\CacheServiceProvider',
    4 => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    5 => 'Illuminate\\Concurrency\\ConcurrencyServiceProvider',
    6 => 'Illuminate\\Cookie\\CookieServiceProvider',
    7 => 'Illuminate\\Database\\DatabaseServiceProvider',
    8 => 'Illuminate\\Encryption\\EncryptionServiceProvider',
    9 => 'Illuminate\\Filesystem\\FilesystemServiceProvider',
    10 => 'Illuminate\\Foundation\\Providers\\FoundationServiceProvider',
    11 => 'Illuminate\\Hashing\\HashServiceProvider',
    12 => 'Illuminate\\Mail\\MailServiceProvider',
    13 => 'Illuminate\\Notifications\\NotificationServiceProvider',
    14 => 'Illuminate\\Pagination\\PaginationServiceProvider',
    15 => 'Illuminate\\Auth\\Passwords\\PasswordResetServiceProvider',
    16 => 'Illuminate\\Pipeline\\PipelineServiceProvider',
    17 => 'Illuminate\\Queue\\QueueServiceProvider',
    18 => 'Illuminate\\Redis\\RedisServiceProvider',
    19 => 'Illuminate\\Session\\SessionServiceProvider',
    20 => 'Illuminate\\Translation\\TranslationServiceProvider',
    21 => 'Illuminate\\Validation\\ValidationServiceProvider',
    22 => 'Illuminate\\View\\ViewServiceProvider',
    23 => 'Laravel\\Pail\\PailServiceProvider',
    24 => 'Laravel\\Reverb\\ApplicationManagerServiceProvider',
    25 => 'Laravel\\Reverb\\ReverbServiceProvider',
    26 => 'Laravel\\Sail\\SailServiceProvider',
    27 => 'Laravel\\Sanctum\\SanctumServiceProvider',
    28 => 'Laravel\\Telescope\\TelescopeServiceProvider',
    29 => 'Laravel\\Tinker\\TinkerServiceProvider',
    30 => 'Carbon\\Laravel\\ServiceProvider',
    31 => 'NunoMaduro\\Collision\\Adapters\\Laravel\\CollisionServiceProvider',
    32 => 'Termwind\\Laravel\\TermwindServiceProvider',
    33 => 'Prism\\Prism\\PrismServiceProvider',
    34 => 'Spatie\\LaravelData\\LaravelDataServiceProvider',
    35 => 'Spatie\\StructureDiscoverer\\StructureDiscovererServiceProvider',
    36 => 'App\\Providers\\AppServiceProvider',
    37 => 'App\\Providers\\ChatbotServiceProvider',
    38 => 'App\\Providers\\TelescopeServiceProvider',
  ),
  'eager' => 
  array (
    0 => 'Illuminate\\Auth\\AuthServiceProvider',
    1 => 'Illuminate\\Cookie\\CookieServiceProvider',
    2 => 'Illuminate\\Database\\DatabaseServiceProvider',
    3 => 'Illuminate\\Encryption\\EncryptionServiceProvider',
    4 => 'Illuminate\\Filesystem\\FilesystemServiceProvider',
    5 => 'Illuminate\\Foundation\\Providers\\FoundationServiceProvider',
    6 => 'Illuminate\\Notifications\\NotificationServiceProvider',
    7 => 'Illuminate\\Pagination\\PaginationServiceProvider',
    8 => 'Illuminate\\Session\\SessionServiceProvider',
    9 => 'Illuminate\\View\\ViewServiceProvider',
    10 => 'Laravel\\Pail\\PailServiceProvider',
    11 => 'Laravel\\Reverb\\ReverbServiceProvider',
    12 => 'Laravel\\Sanctum\\SanctumServiceProvider',
    13 => 'Laravel\\Telescope\\TelescopeServiceProvider',
    14 => 'Carbon\\Laravel\\ServiceProvider',
    15 => 'NunoMaduro\\Collision\\Adapters\\Laravel\\CollisionServiceProvider',
    16 => 'Termwind\\Laravel\\TermwindServiceProvider',
    17 => 'Prism\\Prism\\PrismServiceProvider',
    18 => 'Spatie\\LaravelData\\LaravelDataServiceProvider',
    19 => 'Spatie\\StructureDiscoverer\\StructureDiscovererServiceProvider',
    20 => 'App\\Providers\\AppServiceProvider',
    21 => 'App\\Providers\\ChatbotServiceProvider',
    22 => 'App\\Providers\\TelescopeServiceProvider',
  ),
  'deferred' => 
  array (
    'Illuminate\\Broadcasting\\BroadcastManager' => 'Illuminate\\Broadcasting\\BroadcastServiceProvider',
    'Illuminate\\Contracts\\Broadcasting\\Factory' => 'Illuminate\\Broadcasting\\BroadcastServiceProvider',
    'Illuminate\\Contracts\\Broadcasting\\Broadcaster' => 'Illuminate\\Broadcasting\\BroadcastServiceProvider',
    'Illuminate\\Bus\\Dispatcher' => 'Illuminate\\Bus\\BusServiceProvider',
    'Illuminate\\Contracts\\Bus\\Dispatcher' => 'Illuminate\\Bus\\BusServiceProvider',
    'Illuminate\\Contracts\\Bus\\QueueingDispatcher' => 'Illuminate\\Bus\\BusServiceProvider',
    'Illuminate\\Bus\\BatchRepository' => 'Illuminate\\Bus\\BusServiceProvider',
    'Illuminate\\Bus\\DatabaseBatchRepository' => 'Illuminate\\Bus\\BusServiceProvider',
    'cache' => 'Illuminate\\Cache\\CacheServiceProvider',
    'cache.store' => 'Illuminate\\Cache\\CacheServiceProvider',
    'cache.psr6' => 'Illuminate\\Cache\\CacheServiceProvider',
    'memcached.connector' => 'Illuminate\\Cache\\CacheServiceProvider',
    'Illuminate\\Cache\\RateLimiter' => 'Illuminate\\Cache\\CacheServiceProvider',
    'Illuminate\\Foundation\\Console\\AboutCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Cache\\Console\\ClearCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Cache\\Console\\ForgetCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ClearCompiledCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Auth\\Console\\ClearResetsCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ConfigCacheCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ConfigClearCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ConfigShowCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\DbCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\MonitorCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\PruneCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\ShowCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\TableCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\WipeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\DownCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\EnvironmentCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\EnvironmentDecryptCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\EnvironmentEncryptCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\EventCacheCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\EventClearCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\EventListCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Concurrency\\Console\\InvokeSerializedClosureCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\KeyGenerateCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\OptimizeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\OptimizeClearCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\PackageDiscoverCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Cache\\Console\\PruneStaleTagsCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\ClearCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\ListFailedCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\FlushFailedCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\ForgetFailedCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\ListenCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\MonitorCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\PruneBatchesCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\PruneFailedJobsCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\RestartCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\RetryCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\RetryBatchCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\WorkCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\RouteCacheCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\RouteClearCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\RouteListCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\DumpCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Seeds\\SeedCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Console\\Scheduling\\ScheduleFinishCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Console\\Scheduling\\ScheduleListCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Console\\Scheduling\\ScheduleRunCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Console\\Scheduling\\ScheduleClearCacheCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Console\\Scheduling\\ScheduleTestCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Console\\Scheduling\\ScheduleWorkCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Console\\Scheduling\\ScheduleInterruptCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\ShowModelCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\StorageLinkCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\StorageUnlinkCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\UpCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ViewCacheCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ViewClearCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ApiInstallCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\BroadcastingInstallCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Cache\\Console\\CacheTableCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\CastMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ChannelListCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ChannelMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ClassMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ComponentMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ConfigMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ConfigPublishCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ConsoleMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Routing\\Console\\ControllerMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\DocsCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\EnumMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\EventGenerateCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\EventMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ExceptionMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Factories\\FactoryMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\InterfaceMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\JobMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\JobMiddlewareMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\LangPublishCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ListenerMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\MailMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Routing\\Console\\MiddlewareMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ModelMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\NotificationMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Notifications\\Console\\NotificationTableCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ObserverMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\PolicyMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ProviderMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\FailedTableCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\TableCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Queue\\Console\\BatchesTableCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\RequestMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ResourceMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\RuleMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ScopeMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Seeds\\SeederMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Session\\Console\\SessionTableCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ServeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\StubPublishCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\TestMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\TraitMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\VendorPublishCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Foundation\\Console\\ViewMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'migrator' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'migration.repository' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'migration.creator' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Migrations\\Migrator' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Migrations\\MigrateCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Migrations\\FreshCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Migrations\\InstallCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Migrations\\RefreshCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Migrations\\ResetCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Migrations\\RollbackCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Migrations\\StatusCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Database\\Console\\Migrations\\MigrateMakeCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'composer' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
    'Illuminate\\Concurrency\\ConcurrencyManager' => 'Illuminate\\Concurrency\\ConcurrencyServiceProvider',
    'hash' => 'Illuminate\\Hashing\\HashServiceProvider',
    'hash.driver' => 'Illuminate\\Hashing\\HashServiceProvider',
    'mail.manager' => 'Illuminate\\Mail\\MailServiceProvider',
    'mailer' => 'Illuminate\\Mail\\MailServiceProvider',
    'Illuminate\\Mail\\Markdown' => 'Illuminate\\Mail\\MailServiceProvider',
    'auth.password' => 'Illuminate\\Auth\\Passwords\\PasswordResetServiceProvider',
    'auth.password.broker' => 'Illuminate\\Auth\\Passwords\\PasswordResetServiceProvider',
    'Illuminate\\Contracts\\Pipeline\\Hub' => 'Illuminate\\Pipeline\\PipelineServiceProvider',
    'pipeline' => 'Illuminate\\Pipeline\\PipelineServiceProvider',
    'queue' => 'Illuminate\\Queue\\QueueServiceProvider',
    'queue.connection' => 'Illuminate\\Queue\\QueueServiceProvider',
    'queue.failer' => 'Illuminate\\Queue\\QueueServiceProvider',
    'queue.listener' => 'Illuminate\\Queue\\QueueServiceProvider',
    'queue.worker' => 'Illuminate\\Queue\\QueueServiceProvider',
    'redis' => 'Illuminate\\Redis\\RedisServiceProvider',
    'redis.connection' => 'Illuminate\\Redis\\RedisServiceProvider',
    'translator' => 'Illuminate\\Translation\\TranslationServiceProvider',
    'translation.loader' => 'Illuminate\\Translation\\TranslationServiceProvider',
    'validator' => 'Illuminate\\Validation\\ValidationServiceProvider',
    'validation.presence' => 'Illuminate\\Validation\\ValidationServiceProvider',
    'Illuminate\\Contracts\\Validation\\UncompromisedVerifier' => 'Illuminate\\Validation\\ValidationServiceProvider',
    'Laravel\\Reverb\\ApplicationManager' => 'Laravel\\Reverb\\ApplicationManagerServiceProvider',
    'Laravel\\Reverb\\Contracts\\ApplicationProvider' => 'Laravel\\Reverb\\ApplicationManagerServiceProvider',
    'Laravel\\Sail\\Console\\InstallCommand' => 'Laravel\\Sail\\SailServiceProvider',
    'Laravel\\Sail\\Console\\PublishCommand' => 'Laravel\\Sail\\SailServiceProvider',
    'command.tinker' => 'Laravel\\Tinker\\TinkerServiceProvider',
  ),
  'when' => 
  array (
    'Illuminate\\Broadcasting\\BroadcastServiceProvider' => 
    array (
    ),
    'Illuminate\\Bus\\BusServiceProvider' => 
    array (
    ),
    'Illuminate\\Cache\\CacheServiceProvider' => 
    array (
    ),
    'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider' => 
    array (
    ),
    'Illuminate\\Concurrency\\ConcurrencyServiceProvider' => 
    array (
    ),
    'Illuminate\\Hashing\\HashServiceProvider' => 
    array (
    ),
    'Illuminate\\Mail\\MailServiceProvider' => 
    array (
    ),
    'Illuminate\\Auth\\Passwords\\PasswordResetServiceProvider' => 
    array (
    ),
    'Illuminate\\Pipeline\\PipelineServiceProvider' => 
    array (
    ),
    'Illuminate\\Queue\\QueueServiceProvider' => 
    array (
    ),
    'Illuminate\\Redis\\RedisServiceProvider' => 
    array (
    ),
    'Illuminate\\Translation\\TranslationServiceProvider' => 
    array (
    ),
    'Illuminate\\Validation\\ValidationServiceProvider' => 
    array (
    ),
    'Laravel\\Reverb\\ApplicationManagerServiceProvider' => 
    array (
    ),
    'Laravel\\Sail\\SailServiceProvider' => 
    array (
    ),
    'Laravel\\Tinker\\TinkerServiceProvider' => 
    array (
    ),
  ),
);


================================================
FILE: config/app.php
================================================
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Application Name
    |--------------------------------------------------------------------------
    |
    | This value is the name of your application, which will be used when the
    | framework needs to place the application's name in a notification or
    | other UI elements where an application name needs to be displayed.
    |
    */

    'name' => env('APP_NAME', 'Laravel'),

    /*
    |--------------------------------------------------------------------------
    | Application Environment
    |--------------------------------------------------------------------------
    |
    | This value determines the "environment" your application is currently
    | running in. This may determine how you prefer to configure various
    | services the application utilizes. Set this in your ".env" file.
    |
    */

    'env' => env('APP_ENV', 'production'),

    /*
    |--------------------------------------------------------------------------
    | Application Debug Mode
    |--------------------------------------------------------------------------
    |
    | When your application is in debug mode, detailed error messages with
    | stack traces will be shown on every error that occurs within your
    | application. If disabled, a simple generic error page is shown.
    |
    */

    'debug' => (bool) env('APP_DEBUG', false),

    /*
    |--------------------------------------------------------------------------
    | Application URL
    |--------------------------------------------------------------------------
    |
    | This URL is used by the console to properly generate URLs when using
    | the Artisan command line tool. You should set this to the root of
    | the application so that it's available within Artisan commands.
    |
    */

    'url' => env('APP_URL', 'http://localhost'),

    /*
    |--------------------------------------------------------------------------
    | Application Timezone
    |--------------------------------------------------------------------------
    |
    | Here you may specify the default timezone for your application, which
    | will be used by the PHP date and date-time functions. The timezone
    | is set to "UTC" by default as it is suitable for most use cases.
    |
    */

    'timezone' => 'UTC',

    /*
    |--------------------------------------------------------------------------
    | Application Locale Configuration
    |--------------------------------------------------------------------------
    |
    | The application locale determines the default locale that will be used
    | by Laravel's translation / localization methods. This option can be
    | set to any locale for which you plan to have translation strings.
    |
    */

    'locale' => env('APP_LOCALE', 'en'),

    'fallback_locale' => env('APP_FALLBACK_LOCALE', 'en'),

    'faker_locale' => env('APP_FAKER_LOCALE', 'en_US'),

    /*
    |--------------------------------------------------------------------------
    | Encryption Key
    |--------------------------------------------------------------------------
    |
    | This key is utilized by Laravel's encryption services and should be set
    | to a random, 32 character string to ensure that all encrypted values
    | are secure. You should do this prior to deploying the application.
    |
    */

    'cipher' => 'AES-256-CBC',

    'key' => env('APP_KEY'),

    'previous_keys' => [
        ...array_filter(
            explode(',', (string) env('APP_PREVIOUS_KEYS', ''))
        ),
    ],

    /*
    |--------------------------------------------------------------------------
    | Maintenance Mode Driver
    |--------------------------------------------------------------------------
    |
    | These configuration options determine the driver used to determine and
    | manage Laravel's "maintenance mode" status. The "cache" driver will
    | allow maintenance mode to be controlled across multiple machines.
    |
    | Supported drivers: "file", "cache"
    |
    */

    'maintenance' => [
        'driver' => env('APP_MAINTENANCE_DRIVER', 'file'),
        'store' => env('APP_MAINTENANCE_STORE', 'database'),
    ],
];



================================================
FILE: config/auth.php
================================================
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Authentication Defaults
    |--------------------------------------------------------------------------
    |
    | This option defines the default authentication "guard" and password
    | reset "broker" for your application. You may change these values
    | as required, but they're a perfect start for most applications.
    |
    */

    'defaults' => [
        'guard' => env('AUTH_GUARD', 'web'),
        'passwords' => env('AUTH_PASSWORD_BROKER', 'users'),
    ],

    /*
    |--------------------------------------------------------------------------
    | Authentication Guards
    |--------------------------------------------------------------------------
    |
    | Next, you may define every authentication guard for your application.
    | Of course, a great default configuration has been defined for you
    | which utilizes session storage plus the Eloquent user provider.
    |
    | All authentication guards have a user provider, which defines how the
    | users are actually retrieved out of your database or other storage
    | system used by the application. Typically, Eloquent is utilized.
    |
    | Supported: "session"
    |
    */

    'guards' => [
        'web' => [
            'driver' => 'session',
            'provider' => 'users',
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | User Providers
    |--------------------------------------------------------------------------
    |
    | All authentication guards have a user provider, which defines how the
    | users are actually retrieved out of your database or other storage
    | system used by the application. Typically, Eloquent is utilized.
    |
    | If you have multiple user tables or models you may configure multiple
    | providers to represent the model / table. These providers may then
    | be assigned to any extra authentication guards you have defined.
    |
    | Supported: "database", "eloquent"
    |
    */

    'providers' => [
        'users' => [
            'driver' => 'eloquent',
            'model' => env('AUTH_MODEL', App\Models\User::class),
        ],

        // 'users' => [
        //     'driver' => 'database',
        //     'table' => 'users',
        // ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Resetting Passwords
    |--------------------------------------------------------------------------
    |
    | These configuration options specify the behavior of Laravel's password
    | reset functionality, including the table utilized for token storage
    | and the user provider that is invoked to actually retrieve users.
    |
    | The expiry time is the number of minutes that each reset token will be
    | considered valid. This security feature keeps tokens short-lived so
    | they have less time to be guessed. You may change this as needed.
    |
    | The throttle setting is the number of seconds a user must wait before
    | generating more password reset tokens. This prevents the user from
    | quickly generating a very large amount of password reset tokens.
    |
    */

    'passwords' => [
        'users' => [
            'provider' => 'users',
            'table' => env('AUTH_PASSWORD_RESET_TOKEN_TABLE', 'password_reset_tokens'),
            'expire' => 60,
            'throttle' => 60,
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Password Confirmation Timeout
    |--------------------------------------------------------------------------
    |
    | Here you may define the number of seconds before a password confirmation
    | window expires and users are asked to re-enter their password via the
    | confirmation screen. By default, the timeout lasts for three hours.
    |
    */

    'password_timeout' => env('AUTH_PASSWORD_TIMEOUT', 10800),

];



================================================
FILE: config/broadcasting.php
================================================
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Default Broadcaster
    |--------------------------------------------------------------------------
    |
    | This option controls the default broadcaster that will be used by the
    | framework when an event needs to be broadcast. You may set this to
    | any of the connections defined in the "connections" array below.
    |
    | Supported: "reverb", "pusher", "ably", "redis", "log", "null"
    |
    */

    'default' => env('BROADCAST_CONNECTION', 'null'),

    /*
    |--------------------------------------------------------------------------
    | Broadcast Connections
    |--------------------------------------------------------------------------
    |
    | Here you may define all of the broadcast connections that will be used
    | to broadcast events to other systems or over WebSockets. Samples of
    | each available type of connection are provided inside this array.
    |
    */

    'connections' => [

        'reverb' => [
            'driver' => 'reverb',
            'key' => env('REVERB_APP_KEY'),
            'secret' => env('REVERB_APP_SECRET'),
            'app_id' => env('REVERB_APP_ID'),
            'options' => [
                'host' => env('REVERB_HOST'),
                'port' => env('REVERB_PORT', 443),
                'scheme' => env('REVERB_SCHEME', 'https'),
                'useTLS' => env('REVERB_SCHEME', 'https') === 'https',
            ],
            'client_options' => [
                // Guzzle client options: https://docs.guzzlephp.org/en/stable/request-options.html
            ],
        ],

        'pusher' => [
            'driver' => 'pusher',
            'key' => env('PUSHER_APP_KEY'),
            'secret' => env('PUSHER_APP_SECRET'),
            'app_id' => env('PUSHER_APP_ID'),
            'options' => [
                'cluster' => env('PUSHER_APP_CLUSTER'),
                'host' => env('PUSHER_HOST') ?: 'api-'.env('PUSHER_APP_CLUSTER', 'mt1').'.pusher.com',
                'port' => env('PUSHER_PORT', 443),
                'scheme' => env('PUSHER_SCHEME', 'https'),
                'encrypted' => true,
                'useTLS' => env('PUSHER_SCHEME', 'https') === 'https',
            ],
            'client_options' => [
                // Guzzle client options: https://docs.guzzlephp.org/en/stable/request-options.html
            ],
        ],

        'ably' => [
            'driver' => 'ably',
            'key' => env('ABLY_KEY'),
        ],

        'log' => [
            'driver' => 'log',
        ],

        'null' => [
            'driver' => 'null',
        ],

    ],

];



================================================
FILE: config/cache.php
================================================
<?php

use Illuminate\Support\Str;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Cache Store
    |--------------------------------------------------------------------------
    |
    | This option controls the default cache store that will be used by the
    | framework. This connection is utilized if another isn't explicitly
    | specified when running a cache operation inside the application.
    |
    */

    'default' => env('CACHE_STORE', 'database'),

    /*
    |--------------------------------------------------------------------------
    | Cache Stores
    |--------------------------------------------------------------------------
    |
    | Here you may define all of the cache "stores" for your application as
    | well as their drivers. You may even define multiple stores for the
    | same cache driver to group types of items stored in your caches.
    |
    | Supported drivers: "array", "database", "file", "memcached",
    |                    "redis", "dynamodb", "octane", "null"
    |
    */

    'stores' => [

        'array' => [
            'driver' => 'array',
            'serialize' => false,
        ],

        'database' => [
            'driver' => 'database',
            'connection' => env('DB_CACHE_CONNECTION'),
            'table' => env('DB_CACHE_TABLE', 'cache'),
            'lock_connection' => env('DB_CACHE_LOCK_CONNECTION'),
            'lock_table' => env('DB_CACHE_LOCK_TABLE'),
        ],

        'file' => [
            'driver' => 'file',
            'path' => storage_path('framework/cache/data'),
            'lock_path' => storage_path('framework/cache/data'),
        ],

        'memcached' => [
            'driver' => 'memcached',
            'persistent_id' => env('MEMCACHED_PERSISTENT_ID'),
            'sasl' => [
                env('MEMCACHED_USERNAME'),
                env('MEMCACHED_PASSWORD'),
            ],
            'options' => [
                // Memcached::OPT_CONNECT_TIMEOUT => 2000,
            ],
            'servers' => [
                [
                    'host' => env('MEMCACHED_HOST', '127.0.0.1'),
                    'port' => env('MEMCACHED_PORT', 11211),
                    'weight' => 100,
                ],
            ],
        ],

        'redis' => [
            'driver' => 'redis',
            'connection' => env('REDIS_CACHE_CONNECTION', 'cache'),
            'lock_connection' => env('REDIS_CACHE_LOCK_CONNECTION', 'default'),
        ],

        'dynamodb' => [
            'driver' => 'dynamodb',
            'key' => env('AWS_ACCESS_KEY_ID'),
            'secret' => env('AWS_SECRET_ACCESS_KEY'),
            'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
            'table' => env('DYNAMODB_CACHE_TABLE', 'cache'),
            'endpoint' => env('DYNAMODB_ENDPOINT'),
        ],

        'octane' => [
            'driver' => 'octane',
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Cache Key Prefix
    |--------------------------------------------------------------------------
    |
    | When utilizing the APC, database, memcached, Redis, and DynamoDB cache
    | stores, there might be other applications using the same cache. For
    | that reason, you may prefix every cache key to avoid collisions.
    |
    */

    'prefix' => env('CACHE_PREFIX', Str::slug((string) env('APP_NAME', 'laravel')).'-cache-'),

];



================================================
FILE: config/database.php
================================================
<?php

use Illuminate\Support\Str;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Database Connection Name
    |--------------------------------------------------------------------------
    |
    | Here you may specify which of the database connections below you wish
    | to use as your default connection for database operations. This is
    | the connection which will be utilized unless another connection
    | is explicitly specified when you execute a query / statement.
    |
    */

    'default' => env('DB_CONNECTION', 'sqlite'),

    /*
    |--------------------------------------------------------------------------
    | Database Connections
    |--------------------------------------------------------------------------
    |
    | Below are all of the database connections defined for your application.
    | An example configuration is provided for each database system which
    | is supported by Laravel. You're free to add / remove connections.
    |
    */

    'connections' => [

        'sqlite' => [
            'driver' => 'sqlite',
            'url' => env('DB_URL'),
            'database' => env('DB_DATABASE', database_path('database.sqlite')),
            'prefix' => '',
            'foreign_key_constraints' => env('DB_FOREIGN_KEYS', true),
            'busy_timeout' => null,
            'journal_mode' => null,
            'synchronous' => null,
        ],

        'mysql' => [
            'driver' => 'mysql',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', '127.0.0.1'),
            'port' => env('DB_PORT', '3306'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'unix_socket' => env('DB_SOCKET', ''),
            'charset' => env('DB_CHARSET', 'utf8mb4'),
            'collation' => env('DB_COLLATION', 'utf8mb4_unicode_ci'),
            'prefix' => '',
            'prefix_indexes' => true,
            'strict' => true,
            'engine' => null,
            'options' => extension_loaded('pdo_mysql') ? array_filter([
                PDO::MYSQL_ATTR_SSL_CA => env('MYSQL_ATTR_SSL_CA'),
            ]) : [],
        ],

        'mariadb' => [
            'driver' => 'mariadb',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', '127.0.0.1'),
            'port' => env('DB_PORT', '3306'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'unix_socket' => env('DB_SOCKET', ''),
            'charset' => env('DB_CHARSET', 'utf8mb4'),
            'collation' => env('DB_COLLATION', 'utf8mb4_unicode_ci'),
            'prefix' => '',
            'prefix_indexes' => true,
            'strict' => true,
            'engine' => null,
            'options' => extension_loaded('pdo_mysql') ? array_filter([
                PDO::MYSQL_ATTR_SSL_CA => env('MYSQL_ATTR_SSL_CA'),
            ]) : [],
        ],

        'pgsql' => [
            'driver' => 'pgsql',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', '127.0.0.1'),
            'port' => env('DB_PORT', '5432'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'charset' => env('DB_CHARSET', 'utf8'),
            'prefix' => '',
            'prefix_indexes' => true,
            'search_path' => 'public',
            'sslmode' => 'prefer',
        ],

        'sqlsrv' => [
            'driver' => 'sqlsrv',
            'url' => env('DB_URL'),
            'host' => env('DB_HOST', 'localhost'),
            'port' => env('DB_PORT', '1433'),
            'database' => env('DB_DATABASE', 'laravel'),
            'username' => env('DB_USERNAME', 'root'),
            'password' => env('DB_PASSWORD', ''),
            'charset' => env('DB_CHARSET', 'utf8'),
            'prefix' => '',
            'prefix_indexes' => true,
            // 'encrypt' => env('DB_ENCRYPT', 'yes'),
            // 'trust_server_certificate' => env('DB_TRUST_SERVER_CERTIFICATE', 'false'),
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Migration Repository Table
    |--------------------------------------------------------------------------
    |
    | This table keeps track of all the migrations that have already run for
    | your application. Using this information, we can determine which of
    | the migrations on disk haven't actually been run on the database.
    |
    */

    'migrations' => [
        'table' => 'migrations',
        'update_date_on_publish' => true,
    ],

    /*
    |--------------------------------------------------------------------------
    | Redis Databases
    |--------------------------------------------------------------------------
    |
    | Redis is an open source, fast, and advanced key-value store that also
    | provides a richer body of commands than a typical key-value system
    | such as Memcached. You may define your connection settings here.
    |
    */

    'redis' => [

        'client' => env('REDIS_CLIENT', 'phpredis'),

        'options' => [
            'cluster' => env('REDIS_CLUSTER', 'redis'),
            'prefix' => env('REDIS_PREFIX', Str::slug((string) env('APP_NAME', 'laravel')).'-database-'),
            'persistent' => env('REDIS_PERSISTENT', false),
        ],

        'default' => [
            'url' => env('REDIS_URL'),
            'host' => env('REDIS_HOST', '127.0.0.1'),
            'username' => env('REDIS_USERNAME'),
            'password' => env('REDIS_PASSWORD'),
            'port' => env('REDIS_PORT', '6379'),
            'database' => env('REDIS_DB', '0'),
        ],

        'cache' => [
            'url' => env('REDIS_URL'),
            'host' => env('REDIS_HOST', '127.0.0.1'),
            'username' => env('REDIS_USERNAME'),
            'password' => env('REDIS_PASSWORD'),
            'port' => env('REDIS_PORT', '6379'),
            'database' => env('REDIS_CACHE_DB', '1'),
        ],

    ],

];



================================================
FILE: config/filesystems.php
================================================
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Default Filesystem Disk
    |--------------------------------------------------------------------------
    |
    | Here you may specify the default filesystem disk that should be used
    | by the framework. The "local" disk, as well as a variety of cloud
    | based disks are available to your application for file storage.
    |
    */

    'default' => env('FILESYSTEM_DISK', 'local'),

    /*
    |--------------------------------------------------------------------------
    | Filesystem Disks
    |--------------------------------------------------------------------------
    |
    | Below you may configure as many filesystem disks as necessary, and you
    | may even configure multiple disks for the same driver. Examples for
    | most supported storage drivers are configured here for reference.
    |
    | Supported drivers: "local", "ftp", "sftp", "s3"
    |
    */

    'disks' => [

        'local' => [
            'driver' => 'local',
            'root' => storage_path('app/private'),
            'serve' => true,
            'throw' => false,
            'report' => false,
        ],

        'public' => [
            'driver' => 'local',
            'root' => storage_path('app/public'),
            'url' => env('APP_URL').'/storage',
            'visibility' => 'public',
            'throw' => false,
            'report' => false,
        ],

        's3' => [
            'driver' => 's3',
            'key' => env('AWS_ACCESS_KEY_ID'),
            'secret' => env('AWS_SECRET_ACCESS_KEY'),
            'region' => env('AWS_DEFAULT_REGION'),
            'bucket' => env('AWS_BUCKET'),
            'url' => env('AWS_URL'),
            'endpoint' => env('AWS_ENDPOINT'),
            'use_path_style_endpoint' => env('AWS_USE_PATH_STYLE_ENDPOINT', false),
            'throw' => false,
            'report' => false,
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Symbolic Links
    |--------------------------------------------------------------------------
    |
    | Here you may configure the symbolic links that will be created when the
    | `storage:link` Artisan command is executed. The array keys should be
    | the locations of the links and the values should be their targets.
    |
    */

    'links' => [
        public_path('storage') => storage_path('app/public'),
    ],

];



================================================
FILE: config/logging.php
================================================
<?php

use Monolog\Handler\NullHandler;
use Monolog\Handler\StreamHandler;
use Monolog\Handler\SyslogUdpHandler;
use Monolog\Processor\PsrLogMessageProcessor;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Log Channel
    |--------------------------------------------------------------------------
    |
    | This option defines the default log channel that is utilized to write
    | messages to your logs. The value provided here should match one of
    | the channels present in the list of "channels" configured below.
    |
    */

    'default' => env('LOG_CHANNEL', 'stack'),

    /*
    |--------------------------------------------------------------------------
    | Deprecations Log Channel
    |--------------------------------------------------------------------------
    |
    | This option controls the log channel that should be used to log warnings
    | regarding deprecated PHP and library features. This allows you to get
    | your application ready for upcoming major versions of dependencies.
    |
    */

    'deprecations' => [
        'channel' => env('LOG_DEPRECATIONS_CHANNEL', 'null'),
        'trace' => env('LOG_DEPRECATIONS_TRACE', false),
    ],

    /*
    |--------------------------------------------------------------------------
    | Log Channels
    |--------------------------------------------------------------------------
    |
    | Here you may configure the log channels for your application. Laravel
    | utilizes the Monolog PHP logging library, which includes a variety
    | of powerful log handlers and formatters that you're free to use.
    |
    | Available drivers: "single", "daily", "slack", "syslog",
    |                    "errorlog", "monolog", "custom", "stack"
    |
    */

    'channels' => [

        'stack' => [
            'driver' => 'stack',
            'channels' => explode(',', (string) env('LOG_STACK', 'single')),
            'ignore_exceptions' => false,
        ],

        'single' => [
            'driver' => 'single',
            'path' => storage_path('logs/laravel.log'),
            'level' => env('LOG_LEVEL', 'debug'),
            'replace_placeholders' => true,
        ],

        'daily' => [
            'driver' => 'daily',
            'path' => storage_path('logs/laravel.log'),
            'level' => env('LOG_LEVEL', 'debug'),
            'days' => env('LOG_DAILY_DAYS', 14),
            'replace_placeholders' => true,
        ],

        'slack' => [
            'driver' => 'slack',
            'url' => env('LOG_SLACK_WEBHOOK_URL'),
            'username' => env('LOG_SLACK_USERNAME', 'Laravel Log'),
            'emoji' => env('LOG_SLACK_EMOJI', ':boom:'),
            'level' => env('LOG_LEVEL', 'critical'),
            'replace_placeholders' => true,
        ],

        'papertrail' => [
            'driver' => 'monolog',
            'level' => env('LOG_LEVEL', 'debug'),
            'handler' => env('LOG_PAPERTRAIL_HANDLER', SyslogUdpHandler::class),
            'handler_with' => [
                'host' => env('PAPERTRAIL_URL'),
                'port' => env('PAPERTRAIL_PORT'),
                'connectionString' => 'tls://'.env('PAPERTRAIL_URL').':'.env('PAPERTRAIL_PORT'),
            ],
            'processors' => [PsrLogMessageProcessor::class],
        ],

        'stderr' => [
            'driver' => 'monolog',
            'level' => env('LOG_LEVEL', 'debug'),
            'handler' => StreamHandler::class,
            'handler_with' => [
                'stream' => 'php://stderr',
            ],
            'formatter' => env('LOG_STDERR_FORMATTER'),
            'processors' => [PsrLogMessageProcessor::class],
        ],

        'syslog' => [
            'driver' => 'syslog',
            'level' => env('LOG_LEVEL', 'debug'),
            'facility' => env('LOG_SYSLOG_FACILITY', LOG_USER),
            'replace_placeholders' => true,
        ],

        'errorlog' => [
            'driver' => 'errorlog',
            'level' => env('LOG_LEVEL', 'debug'),
            'replace_placeholders' => true,
        ],

        'null' => [
            'driver' => 'monolog',
            'handler' => NullHandler::class,
        ],

        'emergency' => [
            'path' => storage_path('logs/laravel.log'),
        ],

    ],

];



================================================
FILE: config/mail.php
================================================
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Default Mailer
    |--------------------------------------------------------------------------
    |
    | This option controls the default mailer that is used to send all email
    | messages unless another mailer is explicitly specified when sending
    | the message. All additional mailers can be configured within the
    | "mailers" array. Examples of each type of mailer are provided.
    |
    */

    'default' => env('MAIL_MAILER', 'log'),

    /*
    |--------------------------------------------------------------------------
    | Mailer Configurations
    |--------------------------------------------------------------------------
    |
    | Here you may configure all of the mailers used by your application plus
    | their respective settings. Several examples have been configured for
    | you and you are free to add your own as your application requires.
    |
    | Laravel supports a variety of mail "transport" drivers that can be used
    | when delivering an email. You may specify which one you're using for
    | your mailers below. You may also add additional mailers if needed.
    |
    | Supported: "smtp", "sendmail", "mailgun", "ses", "ses-v2",
    |            "postmark", "resend", "log", "array",
    |            "failover", "roundrobin"
    |
    */

    'mailers' => [

        'smtp' => [
            'transport' => 'smtp',
            'scheme' => env('MAIL_SCHEME'),
            'url' => env('MAIL_URL'),
            'host' => env('MAIL_HOST', '127.0.0.1'),
            'port' => env('MAIL_PORT', 2525),
            'username' => env('MAIL_USERNAME'),
            'password' => env('MAIL_PASSWORD'),
            'timeout' => null,
            'local_domain' => env('MAIL_EHLO_DOMAIN', parse_url((string) env('APP_URL', 'http://localhost'), PHP_URL_HOST)),
        ],

        'ses' => [
            'transport' => 'ses',
        ],

        'postmark' => [
            'transport' => 'postmark',
            // 'message_stream_id' => env('POSTMARK_MESSAGE_STREAM_ID'),
            // 'client' => [
            //     'timeout' => 5,
            // ],
        ],

        'resend' => [
            'transport' => 'resend',
        ],

        'sendmail' => [
            'transport' => 'sendmail',
            'path' => env('MAIL_SENDMAIL_PATH', '/usr/sbin/sendmail -bs -i'),
        ],

        'log' => [
            'transport' => 'log',
            'channel' => env('MAIL_LOG_CHANNEL'),
        ],

        'array' => [
            'transport' => 'array',
        ],

        'failover' => [
            'transport' => 'failover',
            'mailers' => [
                'smtp',
                'log',
            ],
            'retry_after' => 60,
        ],

        'roundrobin' => [
            'transport' => 'roundrobin',
            'mailers' => [
                'ses',
                'postmark',
            ],
            'retry_after' => 60,
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Global "From" Address
    |--------------------------------------------------------------------------
    |
    | You may wish for all emails sent by your application to be sent from
    | the same address. Here you may specify a name and address that is
    | used globally for all emails that are sent by your application.
    |
    */

    'from' => [
        'address' => env('MAIL_FROM_ADDRESS', 'hello@example.com'),
        'name' => env('MAIL_FROM_NAME', 'Example'),
    ],

];



================================================
FILE: config/prism.php
================================================
<?php

return [
    'prism_server' => [
        // The middleware that will be applied to the Prism Server routes.
        'middleware' => [],
        'enabled' => env('PRISM_SERVER_ENABLED', false),
    ],
    'providers' => [
        'openai' => [
            'url' => env('OPENAI_URL', 'https://api.openai.com/v1'),
            'api_key' => env('OPENAI_API_KEY', ''),
            'organization' => env('OPENAI_ORGANIZATION', null),
            'project' => env('OPENAI_PROJECT', null),
        ],
        'anthropic' => [
            'api_key' => env('ANTHROPIC_API_KEY', ''),
            'version' => env('ANTHROPIC_API_VERSION', '2023-06-01'),
            'default_thinking_budget' => env('ANTHROPIC_DEFAULT_THINKING_BUDGET', 1024),
            // Include beta strings as a comma separated list.
            'anthropic_beta' => env('ANTHROPIC_BETA', null),
        ],
        'ollama' => [
            'url' => env('OLLAMA_URL', 'http://localhost:11434'),
        ],
        'mistral' => [
            'api_key' => env('MISTRAL_API_KEY', ''),
            'url' => env('MISTRAL_URL', 'https://api.mistral.ai/v1'),
        ],
        'groq' => [
            'api_key' => env('GROQ_API_KEY', ''),
            'url' => env('GROQ_URL', 'https://api.groq.com/openai/v1'),
        ],
        'xai' => [
            'api_key' => env('XAI_API_KEY', ''),
            'url' => env('XAI_URL', 'https://api.x.ai/v1'),
        ],
        'gemini' => [
            'api_key' => env('GEMINI_API_KEY', ''),
            'url' => env('GEMINI_URL', 'https://generativelanguage.googleapis.com/v1beta/models'),
        ],
        'deepseek' => [
            'api_key' => env('DEEPSEEK_API_KEY', ''),
            'url' => env('DEEPSEEK_URL', 'https://api.deepseek.com/v1'),
        ],
        'elevenlabs' => [
            'api_key' => env('ELEVENLABS_API_KEY', ''),
            'url' => env('ELEVENLABS_URL', 'https://api.elevenlabs.io/v1/'),
        ],
        'voyageai' => [
            'api_key' => env('VOYAGEAI_API_KEY', ''),
            'url' => env('VOYAGEAI_URL', 'https://api.voyageai.com/v1'),
        ],
        'openrouter' => [
            'api_key' => env('OPENROUTER_API_KEY', ''),
            'url' => env('OPENROUTER_URL', 'https://openrouter.ai/api/v1'),
            'site' => [
                'http_referer' => env('OPENROUTER_SITE_HTTP_REFERER', null),
                'x_title' => env('OPENROUTER_SITE_X_TITLE', null),
            ],
        ],
    ],
];



================================================
FILE: config/queue.php
================================================
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Default Queue Connection Name
    |--------------------------------------------------------------------------
    |
    | Laravel's queue supports a variety of backends via a single, unified
    | API, giving you convenient access to each backend using identical
    | syntax for each. The default queue connection is defined below.
    |
    */

    'default' => env('QUEUE_CONNECTION', 'database'),

    /*
    |--------------------------------------------------------------------------
    | Queue Connections
    |--------------------------------------------------------------------------
    |
    | Here you may configure the connection options for every queue backend
    | used by your application. An example configuration is provided for
    | each backend supported by Laravel. You're also free to add more.
    |
    | Drivers: "sync", "database", "beanstalkd", "sqs", "redis", "null"
    |
    */

    'connections' => [

        'sync' => [
            'driver' => 'sync',
        ],

        'database' => [
            'driver' => 'database',
            'connection' => env('DB_QUEUE_CONNECTION'),
            'table' => env('DB_QUEUE_TABLE', 'jobs'),
            'queue' => env('DB_QUEUE', 'default'),
            'retry_after' => (int) env('DB_QUEUE_RETRY_AFTER', 90),
            'after_commit' => false,
        ],

        'beanstalkd' => [
            'driver' => 'beanstalkd',
            'host' => env('BEANSTALKD_QUEUE_HOST', 'localhost'),
            'queue' => env('BEANSTALKD_QUEUE', 'default'),
            'retry_after' => (int) env('BEANSTALKD_QUEUE_RETRY_AFTER', 90),
            'block_for' => 0,
            'after_commit' => false,
        ],

        'sqs' => [
            'driver' => 'sqs',
            'key' => env('AWS_ACCESS_KEY_ID'),
            'secret' => env('AWS_SECRET_ACCESS_KEY'),
            'prefix' => env('SQS_PREFIX', 'https://sqs.us-east-1.amazonaws.com/your-account-id'),
            'queue' => env('SQS_QUEUE', 'default'),
            'suffix' => env('SQS_SUFFIX'),
            'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
            'after_commit' => false,
        ],

        'redis' => [
            'driver' => 'redis',
            'connection' => env('REDIS_QUEUE_CONNECTION', 'default'),
            'queue' => env('REDIS_QUEUE', 'default'),
            'retry_after' => (int) env('REDIS_QUEUE_RETRY_AFTER', 90),
            'block_for' => null,
            'after_commit' => false,
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Job Batching
    |--------------------------------------------------------------------------
    |
    | The following options configure the database and table that store job
    | batching information. These options can be updated to any database
    | connection and table which has been defined by your application.
    |
    */

    'batching' => [
        'database' => env('DB_CONNECTION', 'sqlite'),
        'table' => 'job_batches',
    ],

    /*
    |--------------------------------------------------------------------------
    | Failed Queue Jobs
    |--------------------------------------------------------------------------
    |
    | These options configure the behavior of failed queue job logging so you
    | can control how and where failed jobs are stored. Laravel ships with
    | support for storing failed jobs in a simple file or in a database.
    |
    | Supported drivers: "database-uuids", "dynamodb", "file", "null"
    |
    */

    'failed' => [
        'driver' => env('QUEUE_FAILED_DRIVER', 'database-uuids'),
        'database' => env('DB_CONNECTION', 'sqlite'),
        'table' => 'failed_jobs',
    ],

];



================================================
FILE: config/reverb.php
================================================
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Default Reverb Server
    |--------------------------------------------------------------------------
    |
    | This option controls the default server used by Reverb to handle
    | incoming messages as well as broadcasting message to all your
    | connected clients. At this time only "reverb" is supported.
    |
    */

    'default' => env('REVERB_SERVER', 'reverb'),

    /*
    |--------------------------------------------------------------------------
    | Reverb Servers
    |--------------------------------------------------------------------------
    |
    | Here you may define details for each of the supported Reverb servers.
    | Each server has its own configuration options that are defined in
    | the array below. You should ensure all the options are present.
    |
    */

    'servers' => [

        'reverb' => [
            'host' => env('REVERB_SERVER_HOST', '0.0.0.0'),
            'port' => env('REVERB_SERVER_PORT', 8080),
            'path' => env('REVERB_SERVER_PATH', ''),
            'hostname' => env('REVERB_HOST'),
            'options' => [
                'tls' => [],
            ],
            'max_request_size' => env('REVERB_MAX_REQUEST_SIZE', 10_000),
            'scaling' => [
                'enabled' => env('REVERB_SCALING_ENABLED', false),
                'channel' => env('REVERB_SCALING_CHANNEL', 'reverb'),
                'server' => [
                    'url' => env('REDIS_URL'),
                    'host' => env('REDIS_HOST', '127.0.0.1'),
                    'port' => env('REDIS_PORT', '6379'),
                    'username' => env('REDIS_USERNAME'),
                    'password' => env('REDIS_PASSWORD'),
                    'database' => env('REDIS_DB', '0'),
                    'timeout' => env('REDIS_TIMEOUT', 60),
                ],
            ],
            'pulse_ingest_interval' => env('REVERB_PULSE_INGEST_INTERVAL', 15),
            'telescope_ingest_interval' => env('REVERB_TELESCOPE_INGEST_INTERVAL', 15),
        ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Reverb Applications
    |--------------------------------------------------------------------------
    |
    | Here you may define how Reverb applications are managed. If you choose
    | to use the "config" provider, you may define an array of apps which
    | your server will support, including their connection credentials.
    |
    */

    'apps' => [

        'provider' => 'config',

        'apps' => [
            [
                'key' => env('REVERB_APP_KEY'),
                'secret' => env('REVERB_APP_SECRET'),
                'app_id' => env('REVERB_APP_ID'),
                'options' => [
                    'host' => env('REVERB_HOST'),
                    'port' => env('REVERB_PORT', 443),
                    'scheme' => env('REVERB_SCHEME', 'https'),
                    'useTLS' => env('REVERB_SCHEME', 'https') === 'https',
                ],
                'allowed_origins' => ['*'],
                'ping_interval' => env('REVERB_APP_PING_INTERVAL', 60),
                'activity_timeout' => env('REVERB_APP_ACTIVITY_TIMEOUT', 30),
                'max_message_size' => env('REVERB_APP_MAX_MESSAGE_SIZE', 10_000),
            ],
        ],

    ],

];



================================================
FILE: config/sanctum.php
================================================
<?php

use Laravel\Sanctum\Sanctum;

return [

    /*
    |--------------------------------------------------------------------------
    | Stateful Domains
    |--------------------------------------------------------------------------
    |
    | Requests from the following domains / hosts will receive stateful API
    | authentication cookies. Typically, these should include your local
    | and production domains which access your API via a frontend SPA.
    |
    */

    'stateful' => explode(',', env('SANCTUM_STATEFUL_DOMAINS', sprintf(
        '%s%s',
        'localhost,localhost:3000,127.0.0.1,127.0.0.1:8000,::1',
        Sanctum::currentApplicationUrlWithPort(),
        // Sanctum::currentRequestHost(),
    ))),

    /*
    |--------------------------------------------------------------------------
    | Sanctum Guards
    |--------------------------------------------------------------------------
    |
    | This array contains the authentication guards that will be checked when
    | Sanctum is trying to authenticate a request. If none of these guards
    | are able to authenticate the request, Sanctum will use the bearer
    | token that's present on an incoming request for authentication.
    |
    */

    'guard' => ['web'],

    /*
    |--------------------------------------------------------------------------
    | Expiration Minutes
    |--------------------------------------------------------------------------
    |
    | This value controls the number of minutes until an issued token will be
    | considered expired. This will override any values set in the token's
    | "expires_at" attribute, but first-party sessions are not affected.
    |
    */

    'expiration' => null,

    /*
    |--------------------------------------------------------------------------
    | Token Prefix
    |--------------------------------------------------------------------------
    |
    | Sanctum can prefix new tokens in order to take advantage of numerous
    | security scanning initiatives maintained by open source platforms
    | that notify developers if they commit tokens into repositories.
    |
    | See: https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning
    |
    */

    'token_prefix' => env('SANCTUM_TOKEN_PREFIX', ''),

    /*
    |--------------------------------------------------------------------------
    | Sanctum Middleware
    |--------------------------------------------------------------------------
    |
    | When authenticating your first-party SPA with Sanctum you may need to
    | customize some of the middleware Sanctum uses while processing the
    | request. You may change the middleware listed below as required.
    |
    */

    'middleware' => [
        'authenticate_session' => Laravel\Sanctum\Http\Middleware\AuthenticateSession::class,
        'encrypt_cookies' => Illuminate\Cookie\Middleware\EncryptCookies::class,
        'validate_csrf_token' => Illuminate\Foundation\Http\Middleware\ValidateCsrfToken::class,
    ],

];



================================================
FILE: config/services.php
================================================
<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Third Party Services
    |--------------------------------------------------------------------------
    |
    | This file is for storing the credentials for third party services such
    | as Mailgun, Postmark, AWS and more. This file provides the de facto
    | location for this type of information, allowing packages to have
    | a conventional file to locate the various service credentials.
    |
    */

    'postmark' => [
        'token' => env('POSTMARK_TOKEN'),
    ],

    'resend' => [
        'key' => env('RESEND_KEY'),
    ],

    'ses' => [
        'key' => env('AWS_ACCESS_KEY_ID'),
        'secret' => env('AWS_SECRET_ACCESS_KEY'),
        'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
    ],

    'slack' => [
        'notifications' => [
            'bot_user_oauth_token' => env('SLACK_BOT_USER_OAUTH_TOKEN'),
            'channel' => env('SLACK_BOT_USER_DEFAULT_CHANNEL'),
        ],
    ],
    'openai' => [
        'api_key' => env('OPENAI_API_KEY'),
        'model' => env('OPENAI_MODEL', 'gpt-4.1-mini'),
    ],
    // config/services.php
    'ai' => [
        'adapter' => env('AI_ADAPTER', 'chatgpt'),
    ],

    'messaging' => [
        'adapter' => env('MESSAGING_ADAPTER', 'whatsapp'),
    ],

    'whatsapp' => [
        'token' => env('WHATSAPP_TOKEN'),
        'phone_number_id' => env('WHATSAPP_PHONE_NUMBER_ID'),
    ],
    'scheduling_api' => [
        'base_url' => env('SCHEDULING_API_BASE_URL'),
        'token' => env('SCHEDULING_API_TOKEN'),
    ],

    // NOVO: Configuração para o serviço do Google Maps
    'google_maps' => [
        'api_key' => env('GOOGLE_MAPS_API_KEY'),
    ],

];



================================================
FILE: config/session.php
================================================
<?php

use Illuminate\Support\Str;

return [

    /*
    |--------------------------------------------------------------------------
    | Default Session Driver
    |--------------------------------------------------------------------------
    |
    | This option determines the default session driver that is utilized for
    | incoming requests. Laravel supports a variety of storage options to
    | persist session data. Database storage is a great default choice.
    |
    | Supported: "file", "cookie", "database", "memcached",
    |            "redis", "dynamodb", "array"
    |
    */

    'driver' => env('SESSION_DRIVER', 'database'),

    /*
    |--------------------------------------------------------------------------
    | Session Lifetime
    |--------------------------------------------------------------------------
    |
    | Here you may specify the number of minutes that you wish the session
    | to be allowed to remain idle before it expires. If you want them
    | to expire immediately when the browser is closed then you may
    | indicate that via the expire_on_close configuration option.
    |
    */

    'lifetime' => (int) env('SESSION_LIFETIME', 120),

    'expire_on_close' => env('SESSION_EXPIRE_ON_CLOSE', false),

    /*
    |--------------------------------------------------------------------------
    | Session Encryption
    |--------------------------------------------------------------------------
    |
    | This option allows you to easily specify that all of your session data
    | should be encrypted before it's stored. All encryption is performed
    | automatically by Laravel and you may use the session like normal.
    |
    */

    'encrypt' => env('SESSION_ENCRYPT', false),

    /*
    |--------------------------------------------------------------------------
    | Session File Location
    |--------------------------------------------------------------------------
    |
    | When utilizing the "file" session driver, the session files are placed
    | on disk. The default storage location is defined here; however, you
    | are free to provide another location where they should be stored.
    |
    */

    'files' => storage_path('framework/sessions'),

    /*
    |--------------------------------------------------------------------------
    | Session Database Connection
    |--------------------------------------------------------------------------
    |
    | When using the "database" or "redis" session drivers, you may specify a
    | connection that should be used to manage these sessions. This should
    | correspond to a connection in your database configuration options.
    |
    */

    'connection' => env('SESSION_CONNECTION'),

    /*
    |--------------------------------------------------------------------------
    | Session Database Table
    |--------------------------------------------------------------------------
    |
    | When using the "database" session driver, you may specify the table to
    | be used to store sessions. Of course, a sensible default is defined
    | for you; however, you're welcome to change this to another table.
    |
    */

    'table' => env('SESSION_TABLE', 'sessions'),

    /*
    |--------------------------------------------------------------------------
    | Session Cache Store
    |--------------------------------------------------------------------------
    |
    | When using one of the framework's cache driven session backends, you may
    | define the cache store which should be used to store the session data
    | between requests. This must match one of your defined cache stores.
    |
    | Affects: "dynamodb", "memcached", "redis"
    |
    */

    'store' => env('SESSION_STORE'),

    /*
    |--------------------------------------------------------------------------
    | Session Sweeping Lottery
    |--------------------------------------------------------------------------
    |
    | Some session drivers must manually sweep their storage location to get
    | rid of old sessions from storage. Here are the chances that it will
    | happen on a given request. By default, the odds are 2 out of 100.
    |
    */

    'lottery' => [2, 100],

    /*
    |--------------------------------------------------------------------------
    | Session Cookie Name
    |--------------------------------------------------------------------------
    |
    | Here you may change the name of the session cookie that is created by
    | the framework. Typically, you should not need to change this value
    | since doing so does not grant a meaningful security improvement.
    |
    */

    'cookie' => env(
        'SESSION_COOKIE',
        Str::snake((string) env('APP_NAME', 'laravel')).'_session'
    ),

    /*
    |--------------------------------------------------------------------------
    | Session Cookie Path
    |--------------------------------------------------------------------------
    |
    | The session cookie path determines the path for which the cookie will
    | be regarded as available. Typically, this will be the root path of
    | your application, but you're free to change this when necessary.
    |
    */

    'path' => env('SESSION_PATH', '/'),

    /*
    |--------------------------------------------------------------------------
    | Session Cookie Domain
    |--------------------------------------------------------------------------
    |
    | This value determines the domain and subdomains the session cookie is
    | available to. By default, the cookie will be available to the root
    | domain and all subdomains. Typically, this shouldn't be changed.
    |
    */

    'domain' => env('SESSION_DOMAIN'),

    /*
    |--------------------------------------------------------------------------
    | HTTPS Only Cookies
    |--------------------------------------------------------------------------
    |
    | By setting this option to true, session cookies will only be sent back
    | to the server if the browser has a HTTPS connection. This will keep
    | the cookie from being sent to you when it can't be done securely.
    |
    */

    'secure' => env('SESSION_SECURE_COOKIE'),

    /*
    |--------------------------------------------------------------------------
    | HTTP Access Only
    |--------------------------------------------------------------------------
    |
    | Setting this value to true will prevent JavaScript from accessing the
    | value of the cookie and the cookie will only be accessible through
    | the HTTP protocol. It's unlikely you should disable this option.
    |
    */

    'http_only' => env('SESSION_HTTP_ONLY', true),

    /*
    |--------------------------------------------------------------------------
    | Same-Site Cookies
    |--------------------------------------------------------------------------
    |
    | This option determines how your cookies behave when cross-site requests
    | take place, and can be used to mitigate CSRF attacks. By default, we
    | will set this value to "lax" to permit secure cross-site requests.
    |
    | See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#samesitesamesite-value
    |
    | Supported: "lax", "strict", "none", null
    |
    */

    'same_site' => env('SESSION_SAME_SITE', 'lax'),

    /*
    |--------------------------------------------------------------------------
    | Partitioned Cookies
    |--------------------------------------------------------------------------
    |
    | Setting this value to true will tie the cookie to the top-level site for
    | a cross-site context. Partitioned cookies are accepted by the browser
    | when flagged "secure" and the Same-Site attribute is set to "none".
    |
    */

    'partitioned' => env('SESSION_PARTITIONED_COOKIE', false),

];



================================================
FILE: config/telescope.php
================================================
<?php

use Laravel\Telescope\Http\Middleware\Authorize;
use Laravel\Telescope\Watchers;

return [

    /*
    |--------------------------------------------------------------------------
    | Telescope Master Switch
    |--------------------------------------------------------------------------
    |
    | This option may be used to disable all Telescope watchers regardless
    | of their individual configuration, which simply provides a single
    | and convenient way to enable or disable Telescope data storage.
    |
    */

    'enabled' => env('TELESCOPE_ENABLED', true),

    /*
    |--------------------------------------------------------------------------
    | Telescope Domain
    |--------------------------------------------------------------------------
    |
    | This is the subdomain where Telescope will be accessible from. If the
    | setting is null, Telescope will reside under the same domain as the
    | application. Otherwise, this value will be used as the subdomain.
    |
    */

    'domain' => env('TELESCOPE_DOMAIN'),

    /*
    |--------------------------------------------------------------------------
    | Telescope Path
    |--------------------------------------------------------------------------
    |
    | This is the URI path where Telescope will be accessible from. Feel free
    | to change this path to anything you like. Note that the URI will not
    | affect the paths of its internal API that aren't exposed to users.
    |
    */

    'path' => env('TELESCOPE_PATH', 'telescope'),

    /*
    |--------------------------------------------------------------------------
    | Telescope Storage Driver
    |--------------------------------------------------------------------------
    |
    | This configuration options determines the storage driver that will
    | be used to store Telescope's data. In addition, you may set any
    | custom options as needed by the particular driver you choose.
    |
    */

    'driver' => env('TELESCOPE_DRIVER', 'database'),

    'storage' => [
        'database' => [
            'connection' => env('DB_CONNECTION', 'mysql'),
            'chunk' => 1000,
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Telescope Queue
    |--------------------------------------------------------------------------
    |
    | This configuration options determines the queue connection and queue
    | which will be used to process ProcessPendingUpdate jobs. This can
    | be changed if you would prefer to use a non-default connection.
    |
    */

    'queue' => [
        'connection' => env('TELESCOPE_QUEUE_CONNECTION', null),
        'queue' => env('TELESCOPE_QUEUE', null),
        'delay' => env('TELESCOPE_QUEUE_DELAY', 10),
    ],

    /*
    |--------------------------------------------------------------------------
    | Telescope Route Middleware
    |--------------------------------------------------------------------------
    |
    | These middleware will be assigned to every Telescope route, giving you
    | the chance to add your own middleware to this list or change any of
    | the existing middleware. Or, you can simply stick with this list.
    |
    */

    'middleware' => [
        'web',
        Authorize::class,
    ],

    /*
    |--------------------------------------------------------------------------
    | Allowed / Ignored Paths & Commands
    |--------------------------------------------------------------------------
    |
    | The following array lists the URI paths and Artisan commands that will
    | not be watched by Telescope. In addition to this list, some Laravel
    | commands, like migrations and queue commands, are always ignored.
    |
    */

    'only_paths' => [
        // 'api/*'
    ],

    'ignore_paths' => [
        'livewire*',
        'nova-api*',
        'pulse*',
    ],

    'ignore_commands' => [
        //
    ],

    /*
    |--------------------------------------------------------------------------
    | Telescope Watchers
    |--------------------------------------------------------------------------
    |
    | The following array lists the "watchers" that will be registered with
    | Telescope. The watchers gather the application's profile data when
    | a request or task is executed. Feel free to customize this list.
    |
    */

    'watchers' => [
        Watchers\BatchWatcher::class => env('TELESCOPE_BATCH_WATCHER', true),

        Watchers\CacheWatcher::class => [
            'enabled' => env('TELESCOPE_CACHE_WATCHER', true),
            'hidden' => [],
            'ignore' => [],
        ],

        Watchers\ClientRequestWatcher::class => env('TELESCOPE_CLIENT_REQUEST_WATCHER', true),

        Watchers\CommandWatcher::class => [
            'enabled' => env('TELESCOPE_COMMAND_WATCHER', true),
            'ignore' => [],
        ],

        Watchers\DumpWatcher::class => [
            'enabled' => env('TELESCOPE_DUMP_WATCHER', true),
            'always' => env('TELESCOPE_DUMP_WATCHER_ALWAYS', false),
        ],

        Watchers\EventWatcher::class => [
            'enabled' => env('TELESCOPE_EVENT_WATCHER', true),
            'ignore' => [],
        ],

        Watchers\ExceptionWatcher::class => env('TELESCOPE_EXCEPTION_WATCHER', true),

        Watchers\GateWatcher::class => [
            'enabled' => env('TELESCOPE_GATE_WATCHER', true),
            'ignore_abilities' => [],
            'ignore_packages' => true,
            'ignore_paths' => [],
        ],

        Watchers\JobWatcher::class => env('TELESCOPE_JOB_WATCHER', true),

        Watchers\LogWatcher::class => [
            'enabled' => env('TELESCOPE_LOG_WATCHER', true),
            'level' => 'error',
        ],

        Watchers\MailWatcher::class => env('TELESCOPE_MAIL_WATCHER', true),

        Watchers\ModelWatcher::class => [
            'enabled' => env('TELESCOPE_MODEL_WATCHER', true),
            'events' => ['eloquent.*'],
            'hydrations' => true,
        ],

        Watchers\NotificationWatcher::class => env('TELESCOPE_NOTIFICATION_WATCHER', true),

        Watchers\QueryWatcher::class => [
            'enabled' => env('TELESCOPE_QUERY_WATCHER', true),
            'ignore_packages' => true,
            'ignore_paths' => [],
            'slow' => 100,
        ],

        Watchers\RedisWatcher::class => env('TELESCOPE_REDIS_WATCHER', true),

        Watchers\RequestWatcher::class => [
            'enabled' => env('TELESCOPE_REQUEST_WATCHER', true),
            'size_limit' => env('TELESCOPE_RESPONSE_SIZE_LIMIT', 64),
            'ignore_http_methods' => [],
            'ignore_status_codes' => [],
        ],

        Watchers\ScheduleWatcher::class => env('TELESCOPE_SCHEDULE_WATCHER', true),
        Watchers\ViewWatcher::class => env('TELESCOPE_VIEW_WATCHER', true),
    ],
];



================================================
FILE: database/factories/UserFactory.php
================================================
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\User>
 */
class UserFactory extends Factory
{
    /**
     * The current password being used by the factory.
     */
    protected static ?string $password;

    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'name' => fake()->name(),
            'email' => fake()->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => static::$password ??= Hash::make('password'),
            'remember_token' => Str::random(10),
        ];
    }

    /**
     * Indicate that the model's email address should be unverified.
     */
    public function unverified(): static
    {
        return $this->state(fn (array $attributes) => [
            'email_verified_at' => null,
        ]);
    }
}



================================================
FILE: database/migrations/0001_01_01_000000_create_users_table.php
================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });

        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email')->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });

        Schema::create('sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('users');
        Schema::dropIfExists('password_reset_tokens');
        Schema::dropIfExists('sessions');
    }
};



================================================
FILE: database/migrations/0001_01_01_000001_create_cache_table.php
================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('cache', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->mediumText('value');
            $table->integer('expiration');
        });

        Schema::create('cache_locks', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->string('owner');
            $table->integer('expiration');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('cache');
        Schema::dropIfExists('cache_locks');
    }
};



================================================
FILE: database/migrations/0001_01_01_000002_create_jobs_table.php
================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('jobs', function (Blueprint $table) {
            $table->id();
            $table->string('queue')->index();
            $table->longText('payload');
            $table->unsignedTinyInteger('attempts');
            $table->unsignedInteger('reserved_at')->nullable();
            $table->unsignedInteger('available_at');
            $table->unsignedInteger('created_at');
        });

        Schema::create('job_batches', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->string('name');
            $table->integer('total_jobs');
            $table->integer('pending_jobs');
            $table->integer('failed_jobs');
            $table->longText('failed_job_ids');
            $table->mediumText('options')->nullable();
            $table->integer('cancelled_at')->nullable();
            $table->integer('created_at');
            $table->integer('finished_at')->nullable();
        });

        Schema::create('failed_jobs', function (Blueprint $table) {
            $table->id();
            $table->string('uuid')->unique();
            $table->text('connection');
            $table->text('queue');
            $table->longText('payload');
            $table->longText('exception');
            $table->timestamp('failed_at')->useCurrent();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('jobs');
        Schema::dropIfExists('job_batches');
        Schema::dropIfExists('failed_jobs');
    }
};



================================================
FILE: database/migrations/2025_08_06_130530_create_personal_access_tokens_table.php
================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('personal_access_tokens', function (Blueprint $table) {
            $table->id();
            $table->morphs('tokenable');
            $table->text('name');
            $table->string('token', 64)->unique();
            $table->text('abilities')->nullable();
            $table->timestamp('last_used_at')->nullable();
            $table->timestamp('expires_at')->nullable()->index();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('personal_access_tokens');
    }
};



================================================
FILE: database/migrations/2025_08_07_202400_create_telescope_entries_table.php
================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('users', function (Blueprint $table) {
            // Permite que a coluna de email seja nula
            $table->string('email')->nullable()->change();
            // Remove o índice de unicidade da coluna de email
            $table->dropUnique('users_email_unique');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('users', function (Blueprint $table) {
            // Reverte as alterações caso precise de anular a migração
            $table->string('email')->unique()->change();
        });
    }
};


================================================
FILE: database/migrations/2025_08_07_210021_modify_users_table_for_nullable_email.php
================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('users', function (Blueprint $table) {
            //
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('users', function (Blueprint $table) {
            //
        });
    }
};



================================================
FILE: database/migrations/2025_08_08_125847_create_chat_sessions_table.php
================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Cria a tabela para gerir as sessões de chat.
        Schema::create('chat_sessions', function (Blueprint $table) {
            // Usamos um UUID como chave primária, ideal para IDs de sessão.
            $table->uuid('id')->primary();

            // Telefone do participante, pode ser nulo e é indexado para buscas rápidas.
            $table->string('phone_number')->nullable()->index();

            // Coluna JSON para guardar o estado da conversa (ex: app ativa, dados do fluxo).
            $table->json('state')->nullable();

            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('chat_sessions');
    }
};



================================================
FILE: database/migrations/2025_08_26_203428_add_history_to_chat_sessions.php
================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Executa as migrações.
     */
    public function up(): void
    {
        Schema::table('chat_sessions', function (Blueprint $table) {
            $table->json('history')->nullable()->after('state');
        });
    }

    /**
     * Reverte as migrações.
     */
    public function down(): void
    {
        Schema::table('chat_sessions', function (Blueprint $table) {
            $table->dropColumn('history');
        });
    }
};



================================================
FILE: database/migrations/2025_09_01_153819_alter_table_chat_sessions_column_last_sentiment.php
================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Executa as migrações.
     */
    public function up(): void
    {
        Schema::table('chat_sessions', function (Blueprint $table) {
            // Adiciona uma coluna para armazenar a última classificação de sentimento
            $table->string('last_sentiment')->nullable()->after('history');
        });
    }

    /**
     * Reverte as migrações.
     */
    public function down(): void
    {
        Schema::table('chat_sessions', function (Blueprint $table) {
            $table->dropColumn('last_sentiment');
        });
    }
};



================================================
FILE: database/migrations/2025_09_01_155925_alter_table_chat_sessions_column_summary.php
================================================
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('chat_sessions', function (Blueprint $table) {
            // Adiciona uma coluna para o resumo da conversa
            $table->text('summary')->nullable()->after('last_sentiment');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('chat_sessions', function (Blueprint $table) {
            $table->dropColumn('summary');
        });
    }
};



================================================
FILE: database/seeders/DatabaseSeeder.php
================================================
<?php

namespace Database\Seeders;

use App\Models\User;
// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        // User::factory(10)->create();

        User::factory()->create([
            'name' => 'Test User',
            'email' => 'test@example.com',
        ]);
    }
}



================================================
FILE: docker/nginx/default.conf
================================================
# docker/nginx/default.conf
# Arquivo de configuração do Nginx para servir a aplicação Laravel.

server {
    listen 80;
    server_name localhost;
    root /var/www/html/public;

    index index.php index.html;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        # Conecta-se ao serviço 'app' na porta 9000, onde o PHP-FPM está ouvindo
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }

    error_log  /var/log/nginx/error.log;
    access_log /var/log/nginx/access.log;
}



================================================
FILE: public/index.php
================================================
<?php

use Illuminate\Foundation\Application;
use Illuminate\Http\Request;

define('LARAVEL_START', microtime(true));

// Determine if the application is in maintenance mode...
if (file_exists($maintenance = __DIR__.'/../storage/framework/maintenance.php')) {
    require $maintenance;
}

// Register the Composer autoloader...
require __DIR__.'/../vendor/autoload.php';

// Bootstrap Laravel and handle the request...
/** @var Application $app */
$app = require_once __DIR__.'/../bootstrap/app.php';

$app->handleRequest(Request::capture());



================================================
FILE: public/robots.txt
================================================
User-agent: *
Disallow:



================================================
FILE: public/.htaccess
================================================
<IfModule mod_rewrite.c>
    <IfModule mod_negotiation.c>
        Options -MultiViews -Indexes
    </IfModule>

    RewriteEngine On

    # Handle Authorization Header
    RewriteCond %{HTTP:Authorization} .
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]

    # Handle X-XSRF-Token Header
    RewriteCond %{HTTP:x-xsrf-token} .
    RewriteRule .* - [E=HTTP_X_XSRF_TOKEN:%{HTTP:X-XSRF-Token}]

    # Redirect Trailing Slashes If Not A Folder...
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteCond %{REQUEST_URI} (.+)/$
    RewriteRule ^ %1 [L,R=301]

    # Send Requests To Front Controller...
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteRule ^ index.php [L]
</IfModule>



================================================
FILE: resources/css/app.css
================================================
@import 'tailwindcss';

@source '../../vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php';
@source '../../storage/framework/views/*.php';
@source '../**/*.blade.php';
@source '../**/*.js';

@theme {
    --font-sans: 'Instrument Sans', ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',
        'Segoe UI Symbol', 'Noto Color Emoji';
}



================================================
FILE: resources/js/app.js
================================================
import './bootstrap';



================================================
FILE: resources/js/bootstrap.js
================================================
import axios from 'axios';
window.axios = axios;

window.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';



================================================
FILE: resources/views/webchat.blade.php
================================================
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat de Teste Local</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 font-sans">
    <div class="container mx-auto max-w-2xl mt-10 p-4">
        <div class="bg-white rounded-lg shadow-lg">
            <!-- Cabeçalho -->
            <div class="bg-blue-600 text-white p-4 rounded-t-lg flex justify-between items-center">
                <div>
                    <h1 class="text-2xl font-bold">Chatbot Local</h1>
                    <p class="text-sm">Ambiente de Desenvolvimento</p>
                </div>
                <form action="{{ route('chat.clear') }}" method="POST">
                    @csrf
                    <button type="submit" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg text-sm transition duration-300">
                        Limpar Conversa
                    </button>
                </form>
            </div>

            <!-- Área de Mensagens -->
            <div id="chat-box" class="p-6 h-96 overflow-y-auto">
                @forelse ($history as $chat)
                    @if ($chat['sender'] === 'user')
                        <div class="flex justify-end mb-4">
                            <div class="bg-blue-500 text-white rounded-lg py-2 px-4 max-w-xs break-words">
                                {{ $chat['message'] }}
                            </div>
                        </div>
                    @else
                        <div class="flex justify-start mb-4">
                            <div class="bg-gray-200 text-gray-800 rounded-lg py-2 px-4 max-w-xs break-words">
                                {!! \Illuminate\Support\Str::markdown($chat['message']) !!}
                            </div>
                        </div>
                    @endif
                @empty
                    <div class="text-center text-gray-500">
                        Nenhuma mensagem ainda. Envie uma para começar!
                    </div>
                @endforelse
            </div>

            <!-- Formulário de Envio -->
            <div class="p-4 border-t border-gray-200">
                <form action="{{ route('chat.store') }}" method="POST">
                    @csrf
                    <div class="flex">
                        <input
                            type="text"
                            name="message"
                            class="flex-grow rounded-l-lg p-3 border-t mr-0 border-b border-l text-gray-800 border-gray-200 bg-white focus:outline-none"
                            placeholder="Digite sua mensagem..."
                            autofocus
                        />
                        <button type="submit" class="px-6 rounded-r-lg bg-blue-600 text-white font-bold p-3 uppercase border-blue-600 border-t border-b border-r hover:bg-blue-700 transition duration-300">
                            Enviar
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <script>
        // Rola a caixa de chat para a última mensagem
        const chatBox = document.getElementById('chat-box');
        chatBox.scrollTop = chatBox.scrollHeight;
    </script>
</body>
</html>



================================================
FILE: routes/api.php
================================================
<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use App\Http\Controllers\ApiChatController;

Route::get('/user', function (Request $request) {
    return $request->user();
})->middleware('auth:sanctum');


// Rota para receber as mensagens da interface Streamlit
Route::post('/chat', [ApiChatController::class, 'handle']);


================================================
FILE: routes/channels.php
================================================
<?php

use Illuminate\Support\Facades\Broadcast;

Broadcast::channel('App.Models.User.{id}', function ($user, $id) {
    return (int) $user->id === (int) $id;
});



================================================
FILE: routes/console.php
================================================
<?php

use Illuminate\Foundation\Inspiring;
use Illuminate\Support\Facades\Artisan;

Artisan::command('inspire', function () {
    $this->comment(Inspiring::quote());
})->purpose('Display an inspiring quote');



================================================
FILE: routes/web.php
================================================
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\WebChatController;

/*
|--------------------------------------------------------------------------
| Web Routes
|--------------------------------------------------------------------------
|
| Here is where you can register web routes for your application. These
| routes are loaded by the RouteServiceProvider and all of them will
| be assigned to the "web" middleware group. Make something great!
|
*/

Route::get('/', function () {
    return view('welcome');
});

// Rotas para o Chat de Desenvolvimento Local
Route::get('/chat', [WebChatController::class, 'show'])->name('chat.show');
Route::post('/chat', [WebChatController::class, 'store'])->name('chat.store');
Route::post('/chat/clear', [WebChatController::class, 'clear'])->name('chat.clear');



================================================
FILE: storage/framework/views/fea62ea78877c7118eb545507523b1e3.php
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Meta Information -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="csrf-token" content="<?php echo e(csrf_token()); ?>">

    <link rel="shortcut icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAADQ0lEQVRYCbVXXXLaMBCWaGfIW+kNdIPCS9v0BeUEhRMEThByAuAEDSconCDkBJiX/jxBTxDfoDwm04mVb72WbbBkTIGdEZJ3V7ufdlc/SFGRtF41hHjqCCHbaE0hjMJU8GLa4HeNFoK/FOJiHgQt4u0luU9D659KiDc3QkQ96FqH+6aRfAow4yC4DOnDR14AvOJ/Qzge+CZX48tREHwa+3SdAHjVcoFJyjfxQH6IaFy5olEAcAbnFqsTRM1KqT/SORXdFC1Ec5FC8S7YRyZOAXDOjwo7Cu5zH05uM/OFUQKCdhRTCkAIKrhjcm4oAqAo6fnL8auEeCZfMcUAOCy+apdrq1zeWwDeFOSnD2wqkgjIFFFeC5XbxxZqgTfZ5he+wiD4MicuV7qZFTQKDDkgVo1zL3r0UaR0Ve92ZAizGRNAbnUCmRJA9FALXZZFtxCEqTAbXJNviVD0oPw94++OKAWmuc2NHrDizjbP/+X3Yfpv4bztn0qSXefEq7VhVNMIhPAXj1uO7BOA1xrQwVFuYuXtH9lGDdDFcjDBKG3ZuD1q/etb3oLWv4eo9L8sN/fuRcQzmgAQ32r5+f8zpqrWNJFXbkY0rkCKdgGF6BSk2AiFvTI1km1YacIGWmElzQOUUISCDFeJArZdfcq5dXmQQ61/wE7t2l1wrjligwjI0CkqMCNUe+krR8E5itG1awrGLCMEgOiP/SrpAwBds5wOoJPRes9BREfx5dTljqv9+RGyKulzmQDP9AGArkavoTmUHvAmXAfBxzgCyQHTAR/zKOQF2oAzR9NoCq2E6u9rSV5nHi04omM6Wtl9DrAr5jmdw4xp8bsgvh8IjI+m5Bs1QGTuuC/9VYnU9h7li9gpL6yswLmWpLWC45RA3NhvRw+5XALsvUOWZ82hM0Havpa8qCeI0oAm5QDEtYDwCkWCM1KI8wRp4i2dpIAeEsQwV3AMhbMRbNPzPDtPUgDkkq/Vly6GUDw5weZLd/fqTlOQd4eKV8jOAjz0J6GQV158N2xFwLpilPE2QjEdTbBBOS86J8vOCORdcjTECKq4ZCoT6knMsOo7n2NraS8Aq5idgELjBPwA4wqyRiKHQ9rzZo22POTv+Suv7yMtDTWEQwAAAABJRU5ErkJggg==">

    <meta name="robots" content="noindex, nofollow">

    <title>Telescope<?php echo e(config('app.name') ? ' - ' . config('app.name') : ''); ?></title>

    <!-- Style sheets-->
    <link rel="preconnect" href="https://fonts.bunny.net">
    <link href="https://fonts.bunny.net/css?family=figtree:300,400,500,600" rel="stylesheet" />

    <?php echo e(Laravel\Telescope\Telescope::css()); ?>

    <?php echo e(Laravel\Telescope\Telescope::js()); ?>

</head>
<body>
<div id="telescope" v-cloak>
    <alert :message="alert.message"
           :type="alert.type"
           :auto-close="alert.autoClose"
           :confirmation-proceed="alert.confirmationProceed"
           :confirmation-cancel="alert.confirmationCancel"
           v-if="alert.type"></alert>

    <div class="container mb-5">
        <div class="d-flex align-items-stretch py-4 header">
            <router-link to="/" class="logo d-flex align-items-center">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 80">
                    <path class="fill-primary" d="M0 40a39.87 39.87 0 0 1 11.72-28.28A40 40 0 1 1 0 40zm34 10a4 4 0 0 1-4-4v-2a2 2 0 1 0-4 0v2a4 4 0 0 1-4 4h-2a2 2 0 1 0 0 4h2a4 4 0 0 1 4 4v2a2 2 0 1 0 4 0v-2a4 4 0 0 1 4-4h2a2 2 0 1 0 0-4h-2zm24-24a6 6 0 0 1-6-6v-3a3 3 0 0 0-6 0v3a6 6 0 0 1-6 6h-3a3 3 0 0 0 0 6h3a6 6 0 0 1 6 6v3a3 3 0 0 0 6 0v-3a6 6 0 0 1 6-6h3a3 3 0 0 0 0-6h-3zm-4 36a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM21 28a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"></path>
                </svg>

                <h4 class="mb-0 ml-3"><strong>Laravel</strong> Telescope<?php echo e(config('app.name') ? ' - ' . config('app.name') : ''); ?></h4>
            </router-link>

            <button class="btn btn-muted ml-auto mr-3 d-flex align-items-center py-2" v-on:click.prevent="toggleRecording" :title="recording ? 'Pause recording' : 'Resume recording'">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="icon" fill="currentColor" v-if="recording">
                    <path d="M5.75 3a.75.75 0 00-.75.75v12.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75V3.75A.75.75 0 007.25 3h-1.5zM12.75 3a.75.75 0 00-.75.75v12.5c0 .414.336.75.75.75h1.5a.75.75 0 00.75-.75V3.75a.75.75 0 00-.75-.75h-1.5z" />
                </svg>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="icon" fill="currentColor" v-else>
                    <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z" />
                </svg>
            </button>

            <button class="btn btn-muted mr-3 d-flex align-items-center py-2" v-on:click.prevent="clearEntries" title="Clear entries">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="icon" fill="currentColor">
                    <path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.584.176-2.365.298a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193V3.75A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z" clip-rule="evenodd" />
                </svg>
            </button>

            <button class="btn btn-muted mr-3 d-flex align-items-center py-2" :class="{active: autoLoadsNewEntries}" v-on:click.prevent="autoLoadNewEntries" title="Auto load entries">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="icon" fill="currentColor">
                    <path fill-rule="evenodd" d="M15.312 11.424a5.5 5.5 0 01-9.201 2.466l-.312-.311h2.433a.75.75 0 000-1.5H3.989a.75.75 0 00-.75.75v4.242a.75.75 0 001.5 0v-2.43l.31.31a7 7 0 0011.712-3.138.75.75 0 00-1.449-.39zm1.23-3.723a.75.75 0 00.219-.53V2.929a.75.75 0 00-1.5 0V5.36l-.31-.31A7 7 0 003.239 8.188a.75.75 0 101.448.389A5.5 5.5 0 0113.89 6.11l.311.31h-2.432a.75.75 0 000 1.5h4.243a.75.75 0 00.53-.219z" clip-rule="evenodd" />
                </svg>
            </button>

            <router-link to="/monitored-tags" class="btn btn-muted d-flex align-items-center py-2" title="Monitoring">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="icon" fill="currentColor">
                    <path d="M10 12.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z" />
                    <path fill-rule="evenodd" d="M.664 10.59a1.651 1.651 0 010-1.186A10.004 10.004 0 0110 3c4.257 0 7.893 2.66 9.336 6.41.147.381.146.804 0 1.186A10.004 10.004 0 0110 17c-4.257 0-7.893-2.66-9.336-6.41zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" />
                </svg>
            </router-link>
        </div>

        <div class="row mt-4">
            <div class="col-2 sidebar">
                <ul class="nav flex-column">
                    <li class="nav-item">
                        <router-link active-class="active" to="/requests" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M13.2 2.24a.75.75 0 00.04 1.06l2.1 1.95H6.75a.75.75 0 000 1.5h8.59l-2.1 1.95a.75.75 0 101.02 1.1l3.5-3.25a.75.75 0 000-1.1l-3.5-3.25a.75.75 0 00-1.06.04zm-6.4 8a.75.75 0 00-1.06-.04l-3.5 3.25a.75.75 0 000 1.1l3.5 3.25a.75.75 0 101.02-1.1l-2.1-1.95h8.59a.75.75 0 000-1.5H4.66l2.1-1.95a.75.75 0 00.04-1.06z" clip-rule="evenodd" />
                            </svg>
                            <span>Requests</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/commands" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M3.25 3A2.25 2.25 0 001 5.25v9.5A2.25 2.25 0 003.25 17h13.5A2.25 2.25 0 0019 14.75v-9.5A2.25 2.25 0 0016.75 3H3.25zm.943 8.752a.75.75 0 01.055-1.06L6.128 9l-1.88-1.693a.75.75 0 111.004-1.114l2.5 2.25a.75.75 0 010 1.114l-2.5 2.25a.75.75 0 01-1.06-.055zM9.75 10.25a.75.75 0 000 1.5h2.5a.75.75 0 000-1.5h-2.5z" clip-rule="evenodd" />
                            </svg>
                            <span>Commands</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/schedule" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm.75-13a.75.75 0 00-1.5 0v5c0 .414.336.75.75.75h4a.75.75 0 000-1.5h-3.25V5z" clip-rule="evenodd" />
                            </svg>
                            <span>Schedule</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/jobs" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M2 4.5A2.5 2.5 0 014.5 2h11a2.5 2.5 0 010 5h-11A2.5 2.5 0 012 4.5zM2.75 9.083a.75.75 0 000 1.5h14.5a.75.75 0 000-1.5H2.75zM2.75 12.663a.75.75 0 000 1.5h14.5a.75.75 0 000-1.5H2.75zM2.75 16.25a.75.75 0 000 1.5h14.5a.75.75 0 100-1.5H2.75z" />
                            </svg>
                            <span>Jobs</span>
                        </router-link>
                    </li>


                    <li class="nav-item mt-3">
                        <router-link active-class="active" to="/batches" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M2 3.75A.75.75 0 012.75 3h14.5a.75.75 0 010 1.5H2.75A.75.75 0 012 3.75zm0 4.167a.75.75 0 01.75-.75h14.5a.75.75 0 010 1.5H2.75a.75.75 0 01-.75-.75zm0 4.166a.75.75 0 01.75-.75h14.5a.75.75 0 010 1.5H2.75a.75.75 0 01-.75-.75zm0 4.167a.75.75 0 01.75-.75h14.5a.75.75 0 010 1.5H2.75a.75.75 0 01-.75-.75z" clip-rule="evenodd" />
                            </svg>
                            <span>Batches</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/cache" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M4.606 12.97a.75.75 0 01-.134 1.051 2.494 2.494 0 00-.93 2.437 2.494 2.494 0 002.437-.93.75.75 0 111.186.918 3.995 3.995 0 01-4.482 1.332.75.75 0 01-.461-.461 3.994 3.994 0 011.332-4.482.75.75 0 011.052.134z" clip-rule="evenodd" />
                                <path fill-rule="evenodd" d="M5.752 12A13.07 13.07 0 008 14.248v4.002c0 .414.336.75.75.75a5 5 0 004.797-6.414 12.984 12.984 0 005.45-10.848.75.75 0 00-.735-.735 12.984 12.984 0 00-10.849 5.45A5 5 0 001 11.25c.001.414.337.75.751.75h4.002zM13 9a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" />
                            </svg>
                            <span>Cache</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/dumps" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M4.25 2A2.25 2.25 0 002 4.25v11.5A2.25 2.25 0 004.25 18h11.5A2.25 2.25 0 0018 15.75V4.25A2.25 2.25 0 0015.75 2H4.25zm4.03 6.28a.75.75 0 00-1.06-1.06L4.97 9.47a.75.75 0 000 1.06l2.25 2.25a.75.75 0 001.06-1.06L6.56 10l1.72-1.72zm4.5-1.06a.75.75 0 10-1.06 1.06L13.44 10l-1.72 1.72a.75.75 0 101.06 1.06l2.25-2.25a.75.75 0 000-1.06l-2.25-2.25z" clip-rule="evenodd" />
                            </svg>
                            <span>Dumps</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/events" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M13.92 3.845a19.361 19.361 0 01-6.3 1.98C6.765 5.942 5.89 6 5 6a4 4 0 00-.504 7.969 15.974 15.974 0 001.271 3.341c.397.77 1.342 1 2.05.59l.867-.5c.726-.42.94-1.321.588-2.021-.166-.33-.315-.666-.448-1.004 1.8.358 3.511.964 5.096 1.78A17.964 17.964 0 0015 10c0-2.161-.381-4.234-1.08-6.155zM15.243 3.097A19.456 19.456 0 0116.5 10c0 2.431-.445 4.758-1.257 6.904l-.03.077a.75.75 0 001.401.537 20.902 20.902 0 001.312-5.745 1.999 1.999 0 000-3.545 20.902 20.902 0 00-1.312-5.745.75.75 0 00-1.4.537l.029.077z" />
                            </svg>
                            <span>Events</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/exceptions" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M6.56 1.14a.75.75 0 01.177 1.045 3.989 3.989 0 00-.464.86c.185.17.382.329.59.473A3.993 3.993 0 0110 2c1.272 0 2.405.594 3.137 1.518.208-.144.405-.302.59-.473a3.989 3.989 0 00-.464-.86.75.75 0 011.222-.869c.369.519.65 1.105.822 1.736a.75.75 0 01-.174.707 7.03 7.03 0 01-1.299 1.098A4 4 0 0114 6c0 .52-.301.963-.723 1.187a6.961 6.961 0 01-1.158.486c.13.208.231.436.296.679 1.413-.174 2.779-.5 4.081-.96a19.655 19.655 0 00-.09-2.319.75.75 0 111.493-.146 21.239 21.239 0 01.08 3.028.75.75 0 01-.482.667 20.874 20.874 0 01-5.153 1.249 2.51 2.51 0 01-.107.247 20.86 20.86 0 015.253 1.257.75.75 0 01.48.74 20.946 20.946 0 01-.907 5.107.75.75 0 01-1.433-.444c.415-1.34.69-2.743.806-4.19-.495-.174-1-.328-1.512-.461.05.284.076.575.076.873 0 1.814-.517 3.312-1.426 4.37A4.639 4.639 0 0110 19a4.64 4.64 0 01-3.574-1.63C5.516 16.311 5 14.813 5 13c0-.298.026-.59.076-.873-.513.133-1.017.287-1.512.46.116 1.448.39 2.85.806 4.191a.75.75 0 01-1.433.444 20.94 20.94 0 01-.908-5.107.75.75 0 01.482-.74 20.857 20.857 0 015.252-1.257 2.481 2.481 0 01-.107-.247 20.874 20.874 0 01-5.153-1.249.75.75 0 01-.482-.667 21.342 21.342 0 01.08-3.028.75.75 0 111.493.146 19.745 19.745 0 00-.09 2.32c1.302.459 2.668.785 4.08.959.066-.243.166-.471.297-.679a6.962 6.962 0 01-1.158-.486A1.348 1.348 0 016 6a4 4 0 01.166-1.143 7.032 7.032 0 01-1.3-1.098.75.75 0 01-.173-.707 5.48 5.48 0 01.822-1.736.75.75 0 011.046-.176z" clip-rule="evenodd" />
                            </svg>
                            <span>Exceptions</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/gates" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clip-rule="evenodd" />
                            </svg>
                            <span>Gates</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/client-requests" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-1.5 0a6.5 6.5 0 11-11-4.69v.447a3.5 3.5 0 001.025 2.475L8.293 10 8 10.293a1 1 0 000 1.414l1.06 1.06a1.5 1.5 0 01.44 1.061v.363a1 1 0 00.553.894l.276.139a1 1 0 001.342-.448l1.454-2.908a1.5 1.5 0 00-.281-1.731l-.772-.772a1 1 0 00-1.023-.242l-.384.128a.5.5 0 01-.606-.25l-.296-.592a.481.481 0 01.646-.646l.262.131a1 1 0 00.447.106h.188a1 1 0 00.949-1.316l-.068-.204a.5.5 0 01.149-.538l1.44-1.234A6.492 6.492 0 0116.5 10z" clip-rule="evenodd" />
                            </svg>
                            <span>HTTP Client</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/logs" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M2 3a1 1 0 00-1 1v1a1 1 0 001 1h16a1 1 0 001-1V4a1 1 0 00-1-1H2z" />
                                <path fill-rule="evenodd" d="M2 7.5h16l-.811 7.71a2 2 0 01-1.99 1.79H4.802a2 2 0 01-1.99-1.79L2 7.5zM7 11a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1z" clip-rule="evenodd" />
                            </svg>
                            <span>Logs</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/mail" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M3 4a2 2 0 00-2 2v1.161l8.441 4.221a1.25 1.25 0 001.118 0L19 7.162V6a2 2 0 00-2-2H3z" />
                                <path d="M19 8.839l-7.77 3.885a2.75 2.75 0 01-2.46 0L1 8.839V14a2 2 0 002 2h14a2 2 0 002-2V8.839z" />
                            </svg>
                            <span>Mail</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/models" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M1 6a3 3 0 013-3h12a3 3 0 013 3v8a3 3 0 01-3 3H4a3 3 0 01-3-3V6zm4 1.5a2 2 0 114 0 2 2 0 01-4 0zm2 3a4 4 0 00-3.665 2.395.75.75 0 00.416 1A8.98 8.98 0 007 14.5a8.98 8.98 0 003.249-.604.75.75 0 00.416-1.001A4.001 4.001 0 007 10.5zm5-3.75a.75.75 0 01.75-.75h2.5a.75.75 0 010 1.5h-2.5a.75.75 0 01-.75-.75zm0 6.5a.75.75 0 01.75-.75h2.5a.75.75 0 010 1.5h-2.5a.75.75 0 01-.75-.75zm.75-4a.75.75 0 000 1.5h2.5a.75.75 0 000-1.5h-2.5z" clip-rule="evenodd" />
                            </svg>
                            <span>Models</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/notifications" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M4.214 3.227a.75.75 0 00-1.156-.956 8.97 8.97 0 00-1.856 3.826.75.75 0 001.466.316 7.47 7.47 0 011.546-3.186zM16.942 2.271a.75.75 0 00-1.157.956 7.47 7.47 0 011.547 3.186.75.75 0 001.466-.316 8.971 8.971 0 00-1.856-3.826z" />
                                <path fill-rule="evenodd" d="M10 2a6 6 0 00-6 6c0 1.887-.454 3.665-1.257 5.234a.75.75 0 00.515 1.076 32.94 32.94 0 003.256.508 3.5 3.5 0 006.972 0 32.933 32.933 0 003.256-.508.75.75 0 00.515-1.076A11.448 11.448 0 0116 8a6 6 0 00-6-6zm0 14.5a2 2 0 01-1.95-1.557 33.54 33.54 0 003.9 0A2 2 0 0110 16.5z" clip-rule="evenodd" />
                            </svg>
                            <span>Notifications</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/queries" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 1c3.866 0 7 1.79 7 4s-3.134 4-7 4-7-1.79-7-4 3.134-4 7-4zm5.694 8.13c.464-.264.91-.583 1.306-.952V10c0 2.21-3.134 4-7 4s-7-1.79-7-4V8.178c.396.37.842.688 1.306.953C5.838 10.006 7.854 10.5 10 10.5s4.162-.494 5.694-1.37zM3 13.179V15c0 2.21 3.134 4 7 4s7-1.79 7-4v-1.822c-.396.37-.842.688-1.306.953-1.532.875-3.548 1.369-5.694 1.369s-4.162-.494-5.694-1.37A7.009 7.009 0 013 13.179z" clip-rule="evenodd" />
                            </svg>
                            <span>Queries</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/redis" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M.96 9.84c1.35.61 6.83 2.83 7.73 3.26.93.44 1.58.45 2.75-.16 1.13-.59 6.21-2.68 7.6-3.36l.16.06c1.04.38 1.08.7.01 1.25-1.06.56-6.59 2.83-7.77 3.44-1.17.62-1.82.61-2.75.17-.93-.45-6.81-2.82-7.87-3.33-1.06-.5-1.08-.85-.04-1.26l.18-.07zM.8 13.19h.01c1.06.5 6.94 2.88 7.87 3.33.93.44 1.58.45 2.75-.17 1.17-.6 6.6-2.84 7.74-3.42h.02c1.04.39 1.08.7.01 1.26-1.06.55-6.59 2.82-7.77 3.44-1.17.61-1.82.6-2.75.16-.93-.44-6.81-2.82-7.87-3.33-1.06-.5-1.08-.85-.04-1.26l.03-.01zm18.4-5.71c-1.06.55-6.59 2.82-7.77 3.44-1.17.61-1.82.6-2.75.16-.93-.44-6.81-2.82-7.87-3.32C-.24 7.25-.26 6.9.78 6.49c1.04-.4 6.89-2.7 8.12-3.14 1.24-.44 1.67-.46 2.72-.07 1.05.38 6.54 2.57 7.58 2.95 1.04.38 1.08.7.01 1.25zm-6.59-1.95l-1.34-.5.36-.86-1.32.44-1.4-.55.45.83-1.5.53 2 .18.63 1.04.39-.93 1.73-.18zm-2.22 4.53L11.8 8l-4.63.7 3.23 1.35zm-4.48-2.1c1.37 0 2.47-.42 2.47-.95s-1.1-.96-2.47-.96-2.48.43-2.48.96 1.11.96 2.48.96zm8.75-2.17v2.16l2.74-1.08-2.74-1.08zm-3.03 1.2l2.73 1.08.3-.12V5.8l-3.03 1.2z"></path>
                            </svg>
                            <span>Redis</span>
                        </router-link>
                    </li>
                    <li class="nav-item">
                        <router-link active-class="active" to="/views" class="nav-link d-flex align-items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M3.25 3A2.25 2.25 0 001 5.25v9.5A2.25 2.25 0 003.25 17h13.5A2.25 2.25 0 0019 14.75v-9.5A2.25 2.25 0 0016.75 3H3.25zM2.5 9v5.75c0 .414.336.75.75.75h13.5a.75.75 0 00.75-.75V9h-15zM4 5.25a.75.75 0 00-.75.75v.01c0 .414.336.75.75.75h.01a.75.75 0 00.75-.75V6a.75.75 0 00-.75-.75H4zM6.25 6A.75.75 0 017 5.25h.01a.75.75 0 01.75.75v.01a.75.75 0 01-.75.75H7a.75.75 0 01-.75-.75V6zM10 5.25a.75.75 0 00-.75.75v.01c0 .414.336.75.75.75h.01a.75.75 0 00.75-.75V6a.75.75 0 00-.75-.75H10z" clip-rule="evenodd" />
                            </svg>
                            <span>Views</span>
                        </router-link>
                    </li>
                </ul>
            </div>

            <div class="col-10">
                <router-view></router-view>
            </div>
        </div>
    </div>
</div>
</body>
</html>
<?php /**PATH /var/www/html/vendor/laravel/telescope/src/../resources/views/layout.blade.php ENDPATH**/ ?>


================================================
FILE: streamlit/Dockerfile
================================================
# streamlit/Dockerfile

# Use uma imagem base do Python
FROM python:3.11-slim

# Defina o diretório de trabalho
WORKDIR /app

# Copie o arquivo de dependências
COPY requirements.txt .

RUN pip install --upgrade pip

# Instale as dependências
RUN pip install --no-cache-dir -r requirements.txt

# Copie o código da aplicação
COPY . .

# Expõe a porta padrão do Streamlit
EXPOSE 8501

# Comando para rodar a aplicação
CMD ["streamlit", "run", "streamlit_chat.py"]



================================================
FILE: streamlit/requirements.txt
================================================
streamlit
requests
websockets
pusherclient
pysher


================================================
FILE: streamlit/streamlit_chat.py
================================================
import streamlit as st
import requests
import uuid
import threading
import time
import pysher
import json
import logging
from queue import Queue

# Configuração de logging para depuração
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

st.set_page_config(layout="wide")

# --- Constantes de Configuração ---
CHATBOT_API_URL = "http://nginx/api/chat"
REVERB_APP_KEY = "eu5sgudkyypngdki4iyl"
REVERB_HOST = "reverb"
REVERB_PORT = 8080

# --- Filas no Session State para persistência ---
if "status_queue" not in st.session_state:
    st.session_state.status_queue = Queue()
if "message_queue" not in st.session_state:
    st.session_state.message_queue = Queue()

status_queue = st.session_state.status_queue
message_queue = st.session_state.message_queue

# --- Estado da Sessão ---
if "session_id" not in st.session_state:
    st.session_state.session_id = str(uuid.uuid4())
if "messages" not in st.session_state:
    st.session_state.messages = []
if "pusher_client" not in st.session_state:
    st.session_state.pusher_client = None
if "pusher_connection_status" not in st.session_state:
    st.session_state.pusher_connection_status = "Desconectado"
if "subscribed_channel" not in st.session_state:
    st.session_state.subscribed_channel = None

# --- Funções do Pusher/Reverb ---
def on_message(message):
    logging.critical(f"!!!!!!!!!!!!!! MENSAGEM RECEBIDA VIA WEBSOCKET !!!!!!!!!!!!!!: {message}")
    message_queue.put(message)

def connect_handler(data):
    logging.info(f"Conexão estabelecida com sucesso: {data}")
    status_queue.put("Conectado")

def connect_pusher():
    if st.session_state.get("pusher_client") and st.session_state.pusher_client.connection.state == "connected":
        return

    st.session_state.pusher_connection_status = "A Conectar..."
    logging.info("Tentando conectar ao servidor Reverb...")
    try:
        pusher = pysher.Pusher(
            key=REVERB_APP_KEY,
            custom_host=REVERB_HOST,
            port=REVERB_PORT,
            secure=False,
            log_level=logging.INFO
        )
        pusher.connection.bind('pusher:connection_established', connect_handler)
        
        connect_thread = threading.Thread(target=pusher.connect)
        connect_thread.daemon = True
        connect_thread.start()
        
        st.session_state.pusher_client = pusher
    except Exception as e:
        logging.error(f"Não foi possível conectar ao servidor de WebSocket (Reverb): {e}")
        st.session_state.pusher_connection_status = "Falha na Conexão"
        st.error(f"Falha ao conectar com o servidor de chat em tempo real: {e}")

# --- Inicialização ---
if st.session_state.pusher_client is None:
    connect_pusher()

# Espera pela atualização do status da conexão (elimina condição de corrida)
max_wait_time = 5  # segundos
start_time = time.time()
while time.time() - start_time < max_wait_time and st.session_state.pusher_connection_status != "Conectado":
    if not status_queue.empty():
        status = status_queue.get()
        if st.session_state.pusher_connection_status != status:
            logging.info(f"Atualizando status da conexão para: {status}")
            st.session_state.pusher_connection_status = status
    else:
        time.sleep(0.1)

if st.session_state.pusher_connection_status != "Conectado":
    logging.warning("Timeout aguardando status de conexão. Tentará novamente na próxima execução.")

# Log para verificar o estado ANTES da tentativa de subscrição
logging.info(f"Verificando condição para subscrição: Status='{st.session_state.pusher_connection_status}', Canal Subscrito='{st.session_state.subscribed_channel}'")
logging.info(f"THREAD PRINCIPAL: Antes do antes de se inscrever no canal: {st.session_state}")

# Inscreve-se no canal se a conexão estiver estabelecida
if st.session_state.pusher_connection_status == "Conectado" and st.session_state.subscribed_channel is None:
    logging.info(f"THREAD PRINCIPAL: Antes de se inscrever no canal: {st.session_state}")
    try:
        channel_name = f"chat.{st.session_state.session_id}"
        logging.info(f"THREAD PRINCIPAL: Inscrevendo-se no canal: {channel_name}")
        channel = st.session_state.pusher_client.subscribe(channel_name)
        channel.bind('message.sent', on_message)
        st.session_state.subscribed_channel = channel_name
        logging.info(f"THREAD PRINCIPAL: Inscrição no canal '{channel_name}' concluída.")
        # Não chama st.rerun() aqui para permitir que o script continue e renderize a UI
    except Exception as e:
        logging.error(f"THREAD PRINCIPAL: Erro ao se inscrever no canal: {e}")
        st.session_state.pusher_connection_status = "Erro na Inscrição"

# --- Interface Gráfica (UI) ---
st.title("Interface de Chat - Pés Sem Dor")

with st.sidebar:
    st.header("Configuração")
    st.text_input("Telefone (simulação WhatsApp)", key="user_phone", placeholder="Ex: 11999998888")
    st.text_input("ID do Usuário (Sessão)", value=st.session_state.session_id, disabled=True)
    
    status_color = "green" if st.session_state.pusher_connection_status == "Conectado" else "orange" if st.session_state.pusher_connection_status == "A Conectar..." else "red"
    st.markdown(f"**Status do Chat:** <span style='color:{status_color};'>●</span> {st.session_state.pusher_connection_status}", unsafe_allow_html=True)

    #if st.button("Limpar e Reiniciar Conversa"):
     #   for key in list(st.session_state.keys()):
      #      del st.session_state[key]
       # st.session_state.status_queue = Queue()
        #st.session_state.message_queue = Queue()
        #st.rerun()

st.header("Chat")

# Exibe o histórico de mensagens
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# Processa mensagens da fila
rerun_needed = False
if not message_queue.empty():
    logging.info(f"PROCESSANDO {message_queue.qsize()} MENSAGEM(NS) DA FILA.")
    while not message_queue.empty():
        incoming_message_str = message_queue.get()
        try:
            incoming_message = json.loads(incoming_message_str)
            st.session_state.messages.append({"role": "assistant", "content": incoming_message['responseMessage']})
            rerun_needed = True
        except json.JSONDecodeError as e:
            logging.error(f"Não foi possível decodificar a mensagem recebida como JSON: {e} - Mensagem: {incoming_message_str}")
        except KeyError:
            logging.error(f"A chave 'responseMessage' não foi encontrada na mensagem: {incoming_message_str}")

if rerun_needed:
    st.rerun()

# Captura a nova mensagem do usuário
if prompt := st.chat_input("Digite sua mensagem..."):
    st.session_state.messages.append({"role": "user", "content": prompt})
    
    try:
        payload = {
            "message": prompt,
            "user_id": st.session_state.session_id,
            "phone_number": st.session_state.get("user_phone", "").strip()
        }
        response = requests.post(CHATBOT_API_URL, json=payload, timeout=15)
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        st.error(f"Erro ao enviar mensagem para a API: {e}")
    
    st.rerun()

# Força a re-execução do script para manter a aplicação "viva" e a verificar as filas.
time.sleep(1)
st.rerun()


================================================
FILE: tests/TestCase.php
================================================
<?php

namespace Tests;

use Illuminate\Foundation\Testing\TestCase as BaseTestCase;

abstract class TestCase extends BaseTestCase
{
    //
}



================================================
FILE: tests/Feature/ExampleTest.php
================================================
<?php

namespace Tests\Feature;

// use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class ExampleTest extends TestCase
{
    /**
     * A basic test example.
     */
    public function test_the_application_returns_a_successful_response(): void
    {
        $response = $this->get('/');

        $response->assertStatus(200);
    }
}



================================================
FILE: tests/Unit/ExampleTest.php
================================================
<?php

namespace Tests\Unit;

use PHPUnit\Framework\TestCase;

class ExampleTest extends TestCase
{
    /**
     * A basic test example.
     */
    public function test_that_true_is_true(): void
    {
        $this->assertTrue(true);
    }
}


